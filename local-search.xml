<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>讀書心得：我，真的比不上嗎？虛榮心理學</title>
    <link href="/2024/05/31/review-vanity/"/>
    <url>/2024/05/31/review-vanity/</url>
    
    <content type="html"><![CDATA[<p>之前工作比較忙，沒時間更新部落格，剛好最近看了一本書體悟蠻多的，在這邊分享給大家。</p><span id="more"></span><blockquote><p>最後編輯日期：2024&#x2F;06&#x2F;28</p></blockquote><h2 id="虛榮背後的動機"><a href="#虛榮背後的動機" class="headerlink" title="虛榮背後的動機"></a>虛榮背後的動機</h2><p>這邊先來跟大家聊聊是什麼原因導致虛榮心萌芽的？<br>在此書中有提到非常多種面向，但因礙於文章篇幅，就只選取幾個我印象最深刻的來做舉例。</p><h3 id="越是自卑的人越虛榮"><a href="#越是自卑的人越虛榮" class="headerlink" title="越是自卑的人越虛榮"></a><font color=#d2691e>越是自卑的人越虛榮</font></h3><p>乍看之下，我們可能覺得自卑跟虛榮是毫無相關的東西。但從心理學研究方面，我們發現自卑的人往往更容易做出一些虛榮的舉動。</p><p>此書將人的自卑分為兩種：</p><ol><li><p>擔心別人看見自己：</p><p> 這類人通常因為自卑，導致害怕踏出舒適圈，也不喜歡讓自己處於眾人的目光中。比如去餐廳點合菜時會百般推託，因為怕自己選的菜不好吃會被眾人嫌棄，導致不敢點餐。<br> 如果在很多事情上都是這樣想的話，久而久之他們就會漸漸失去主見，變成隨波逐流的人。</p></li><li><p>擔心別人看不見自己：</p><p> 這類人因自卑導致自尊心極強，過度看重他人給予的評價，擔心被他人忽略。所以當他們發現處處比不過別人時，可能就會渴望透過某些快捷的方式獲得認可。<br> 比如說為自己加上一些頭銜來提升優越感，像是「常說我父母是跨國大企業的主管」、「超越自身能力去貸款名車名包來炫耀」等行為，這種<strong>透過外在條件來掩飾內心自卑的方式就是「虛榮」</strong>。</p></li></ol><p>自卑的人通常有個共通點：<strong>習慣用自己的缺點去跟他人的優點做比較，導致認為自己處處不如他人</strong>，進而喪失自信。</p><h3 id="見不得別人比自己好"><a href="#見不得別人比自己好" class="headerlink" title="見不得別人比自己好"></a><font color=#d2691e>見不得別人比自己好</font></h3><p>每個人都會有好勝心，會時常將自己與他人做比較，尤其是和自己的同溫層比。而適當的攀比行為是一件好事，可以激發我們的潛力，讓我們變得更好，但過度的攀比會消磨我們的心靈，一旦發現自己常常比不上別人，不如自己的預期，就有可能漸漸迷失自己。</p><p>而當迷失之人知道靠自己是無法追上別人時，他們就有可能會劍走偏鋒，透過營造一個假身分讓大家以為自己過得很好。比如常常在社群上 Po 去哪裡玩、買奢侈品等，透過這些<strong>超過自身經濟能力</strong>的物質為自己打造一個假象，讓自己在表面上能比得上他人，這也是虛榮的一種表現方式。</p><h2 id="放過自己，初期心裡調適"><a href="#放過自己，初期心裡調適" class="headerlink" title="放過自己，初期心裡調適"></a>放過自己，初期心裡調適</h2><p>我們都知道不能盲目虛榮，但虛榮心無處不在，我們很難做到完全避免。<br>所以為了對抗它，我們須先調適好自己的想法以減少虛榮心產生的機率，這邊提供幾個簡單的方法給大家參考。</p><h3 id="減少盲目比較"><a href="#減少盲目比較" class="headerlink" title="減少盲目比較"></a><font color=#d2691e>減少盲目比較</font></h3><p>我們都知道「<strong>造成盲目虛榮的原因，大多都是因為跟他人比較所引起的</strong>」。因此，我們要客觀地看待自己，才能減緩這些焦慮，書中有推薦幾個心法：</p><ol><li><p>多跟自己比較</p><p> 當我們跟別人攀比導致心理失衡時，可以嘗試坐下來冥想，將<strong>注意力放在自身身上</strong>。當我們注意力都在自己身上時，理智就比較不會受到外在環境所影響，也能更清晰的分析自己的優劣勢。</p></li><li><p>客觀地看待自已</p><p> <strong>當我們羨慕著他人的時候，往往他人也很可能羨慕著我們</strong>，我們當下的煩惱，可能是對方所羨慕的。所以我們不需要妄自菲薄，每個人都有自己的閃光點，我們要做的是讓這閃光點更加閃耀。</p><p> 「<strong>不要用他人的優點，來跟自己的缺點比較。</strong>」沒有人是十全十美的聖人，我們要做的是認識自身的不足並擁抱它，而不是盲目地跟他人攀比，那只會不斷的內耗。</p></li></ol><h3 id="適當地與人比慘"><a href="#適當地與人比慘" class="headerlink" title="適當地與人比慘"></a><font color=#d2691e>適當地與人比慘</font></h3><p>「比慘」是一種自我安慰的藉口，雖然這聽起來不是一個好方法，但<strong>適當的比慘</strong>確實能讓我們在心理上有個慰藉，也能藉此紓發一下負面情緒。</p><p>「<strong>比慘的目的是為了讓我們能以全新的視角來理解自己</strong>」，透過比慘宣洩負面情緒的同時，也讓我們能看到自己的優勢和幸運。這邊有幾個方式推薦給大家：</p><ol><li><p>傾聽他人的煩惱</p><p> 傾聽別人的煩惱不只能讓他人宣洩負面情緒，也能讓我們知道世界上也有人正經歷著不幸，他們的壓力不會小於我們自己。當我們發現他人比我們還不幸時，心裡會不由自主的覺得其實我們的小煩惱也沒什麼，讓我們原本壓力大的心能得到慰藉。</p></li><li><p>適時關心弱勢團體</p><p> 我們可以偶爾去孤兒院走走，或看一些關懷弱勢的影片，這能讓我們體會到他人的辛苦與不幸，同時也會覺得自己已經很幸福了，不應該被眼前的小問題所牽絆。</p></li></ol><h2 id="進階心法，成為更好的人"><a href="#進階心法，成為更好的人" class="headerlink" title="進階心法，成為更好的人"></a>進階心法，成為更好的人</h2><p>剛剛已經教大家如何轉移自卑的注意力，減少虛榮心的誕生。但那樣還是不夠的，在熟悉上述初期的方法後，我們可以開始主動出擊，打造一個堅強的心來抵禦虛榮。</p><h3 id="通過積極的自我暗示擺脫自卑"><a href="#通過積極的自我暗示擺脫自卑" class="headerlink" title="通過積極的自我暗示擺脫自卑"></a><font color=#d2691e>通過積極的自我暗示擺脫自卑</font></h3><p>生理學家巴甫洛夫曾說：「暗示是人類最簡單的條件反射。從心理機制來講，它是一種被主觀意願肯定的假設，而由於主觀上已肯定了它的存在，心理上便自然也會趨向它。」</p><p>一個積極的暗示會將自信的種子種在名為「潛意識」的土壤中；反之，消極的暗示也會讓這片土壤變得滿目瘡痍。所以該如何建立一個良好的心理暗示呢？</p><ol><li><p>精煉暗示</p><p> 冗長或邏輯性強的語句會引發大腦思考，這會降低暗示效果。比如使用「我能做到 xxx」會比「因為我有 ooo 能力，所以我能做到 xxx」好。</p></li><li><p>使用肯定句</p><p> 避免使用「我不自卑」這種否定消極的暗示，改使用「我有自信」會好很多。</p></li><li><p>恰當的暗示時間</p><p> 心理學家表示：「在大腦處於半意識的狀態時，是潛意識最容易接受意願的時候。」所以像是在剛起床或睡前這兩個時段是我們對自己暗示的最佳時機。</p></li></ol><p>當我們知道如何暗示自己後，接下來要做的就是<strong>反覆暗示</strong>。任何刺激潛意識的行為都不是一次就能成功的，需要不斷的刺激它，才能讓我們的內心收到積極暗示的信號。</p><h3 id="嘗試正向攀比"><a href="#嘗試正向攀比" class="headerlink" title="嘗試正向攀比"></a><font color=#d2691e>嘗試正向攀比</font></h3><p>現今的社會上處處都充斥著攀比，能力攀比、外貌攀比、地位攀比，甚至連自己的小孩也要攀比。</p><p>而攀比又分為「負面攀比」與「正向攀比」。負面攀比就猶如上述所說，因迷失了自我而不斷盲目攀比，甚至使用超過自身經濟能力的方式來偽裝自己。而正向攀比跟負面攀比就差在「理性分析」，並把持住內心，不被情緒牽著鼻子走。以下有幾種方式可以來達到正向攀比：</p><ol><li><p>糾正對他人的認知</p><p> 我們<strong>總是只會看到別人光鮮亮麗的一面，不知道他人為此付出了多少努力</strong>。比如我們都只知道 C 羅是世界足壇的巨星，擁有用不完的財富與名聲，但我們卻不知道 C 羅每天堅持做兩千個伏地挺身，甚至把家裡都改造成健身房。</p><p> 所以我們要「理性地」看待我們與他人的差距，而不是只是盲目攀比。</p></li><li><p>充實自己，增加自身的底蘊</p><p> 通常會出現負面攀比，是因為期望值與現實不相符，導致內心不平衡。因此，應該增強自己的實力，減緩內心的不安情緒，讓自己能更理性地分析自我。</p></li></ol><h3 id="建立成長型思維模式"><a href="#建立成長型思維模式" class="headerlink" title="建立成長型思維模式"></a><font color=#d2691e>建立成長型思維模式</font></h3><p>成長型思維的相反就是固定性思維。通常固定性思維會有以下幾個特點：</p><ul><li>只注重結果，不在意過程</li><li>思考邏輯固化，會將一切看成是固定的，不會因為人而改變</li></ul><p>比如固定性思維會覺得擁有名車名包的人就是成功人士；一個人之所以成功是因為他天賦好。但成場型思維的人會去思考背後的原因，像是知道擁有名車名包的人可能是貸款買的，或是他在本業上付出了很多的努力才有機會買到這些奢侈品，還有一個人成功固然有天賦幫助，但背後付出的努力也一定是我們無法輕易想像的。</p><p>然而要如何培養成長性思維呢？書中給了我們幾個建議：</p><ol><li><p>接納自己</p><p> 擁有成長思維的人會理性分析自己的優劣勢，知道自己的不足處並接納它。只有接納缺點，我們才可以正視它，之後才能制定後續方案來彌補。</p><p> 而且通常我們越關注自己的缺點，他人就越容易會意識到它。而當我們忽視了缺點，並充分展現自己的優點後，他人就會被我們的優點吸引住目光而忽略缺點。</p></li><li><p>視挑戰為機遇</p><p> 正常人都會希望處在舒適圈，不願接受挑戰。但擁有成長思維的人不一樣<strong>，</strong>他們<strong>注重過程而非結果</strong>，所以他們都會傾向於接受挑戰，因為就算挑戰失敗了，也能從失敗中汲取經驗。</p><p> 古人云：「勝敗乃兵家常事。」每個人都有失敗的時候，我們不能因為畏懼失敗而止步不前。</p></li><li><p>注重自身的努力，而非別人的認可</p><p> 很多時候我們不願意踏出一步是因為身旁的人都不看好你，導致開始自我懷疑，甚至懷疑是不是自己真的錯了。但我們應該換個思維，如果我們踏出了這一步，就等於贏了昨天的自己，就算達不到別人的認可那又如何。</p><p> 書中有一句話我很喜歡：「<strong>與其將批判自己的標準交給別人，不如將目光看向自己，挖掘自己的優點並喜歡自己。</strong>」</p></li></ol><h2 id="書中其他金句"><a href="#書中其他金句" class="headerlink" title="書中其他金句"></a>書中其他金句</h2><ul><li>幸福不取決於你擁有多少東西，而在於你對這些東西的理解。只有能夠隨心所欲地體驗自己的精神和生活，才能感受到幸福。</li><li>令我們感到自卑的往往不是事件本身，而是對這件事情的認知。</li><li>一個人的幸福程度，取決於他能夠在多大程度上獨立於這個世界。</li><li>人真正變強大，不是因為守著著自尊心，而是當拋開自尊心的時候。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Book-Review</category>
      
      <category>Inspirational</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Book-Review</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>設計模式：觀察者模式</title>
    <link href="/2023/10/05/design-pattern-observer/"/>
    <url>/2023/10/05/design-pattern-observer/</url>
    
    <content type="html"><![CDATA[<p>接下來跟大家分享一個在前後端都會經常看到的模式 ──「觀察者模式」。</p><span id="more"></span><blockquote><p>最後編輯日期：2024&#x2F;01&#x2F;29</p></blockquote><h2 id="什麼是觀察者模式（Observer-Pattern）？"><a href="#什麼是觀察者模式（Observer-Pattern）？" class="headerlink" title="什麼是觀察者模式（Observer Pattern）？"></a>什麼是觀察者模式（Observer Pattern）？</h2><p>觀察者模式是一種<strong>行為型</strong>的設計模式，它主要是用來定義對象間「<font color=#FF0000><strong>一對多</strong></font>」的<strong>依賴關係</strong>。<br>這種依賴關係是一種<strong>鬆耦合依賴</strong>。當我們的主題對象狀態產生變化時，會去通知與其相關的觀察者對象。</p><h3 id="觀察者模式中的角色："><a href="#觀察者模式中的角色：" class="headerlink" title="觀察者模式中的角色："></a><font color=#d2691e>觀察者模式中的角色：</font></h3><ul><li><strong>Subject（主題介面）：</strong>為主題的介面，通常會定義維護觀察者列表的相關接口。</li><li><strong>Observer（觀察者介面）：</strong>為觀察者的介面，通常會定義回調函數的接口。</li><li><strong>Concrete Subject（具體主題）：</strong>也稱為「被觀察者」。它需要維護一個觀察者對象列表，並在自身狀態變化時，通知與其相關的所有觀察者對象。</li><li><strong>Concrete Observer（具體觀察者）：</strong>它需要定義<strong>供主題調用的「回調函數」</strong>。在主題狀態變化時，會執行此回調函數來更新對象本身。</li></ul><h3 id="常見的使用場景："><a href="#常見的使用場景：" class="headerlink" title="常見的使用場景："></a><font color=#d2691e>常見的使用場景：</font></h3><ul><li><p><strong>前端 UI 渲染：</strong><br>  假設網頁中有一圖表，用於顯示當月的銷售量。且當月份變更時，圖表也要跟著變成指定月份的圖表。<br>  這時月份的下拉選單就是「主題」，而會跟著月份變更的圖表就是「觀察者」。</p></li><li><p><strong>易擴展的功能架構：</strong><br>  假設現在有一個購票系統。當用戶完成購票行為後，需要發送 Email 通知購買者，並紀錄日誌。<br>  這時主題為「購票系統」，觀察者為「Email 通知功能」和「日誌功能」。這樣如果之後我們還想加上 Line 通知的話，只要觀察者中添加「Line 通知功能」即可。</p></li></ul><h2 id="觀察者模式範例："><a href="#觀察者模式範例：" class="headerlink" title="觀察者模式範例："></a>觀察者模式範例：</h2><blockquote><p>這邊以「購票系統」來舉例。</p></blockquote><p>假設在完成購票行為之後，需要有多個方式來通知購買者（e.g. Email、Line）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">List</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Observer</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self, subject: <span class="hljs-string">&quot;Subject&quot;</span>, ticket_info: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Subject</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._observers: <span class="hljs-type">List</span>[Observer] = []<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">add_observer</span>(<span class="hljs-params">self, observer: Observer</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._observers.append(observer)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">remove_observer</span>(<span class="hljs-params">self, observer: Observer</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._observers.remove(observer)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">notify_observers</span>(<span class="hljs-params">self, *args, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">for</span> observer <span class="hljs-keyword">in</span> self._observers:<br>            observer.operate(self, *args, **kwargs)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">EmailNotifier</span>(<span class="hljs-title class_ inherited__">Observer</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self, subject: Subject, *args, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Email 通知的業務邏輯...</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Email 通知：已成功購買「<span class="hljs-subst">&#123;kwargs[<span class="hljs-string">&#x27;ticket_name&#x27;</span>]&#125;</span>」的票&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">LineNotifier</span>(<span class="hljs-title class_ inherited__">Observer</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self, subject: Subject, *args, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># Line 通知的業務邏輯...</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Line 通知：已成功購買「<span class="hljs-subst">&#123;kwargs[<span class="hljs-string">&#x27;ticket_name&#x27;</span>]&#125;</span>」的票&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TicketOffice</span>(<span class="hljs-title class_ inherited__">Subject</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">buy_a_ticket</span>(<span class="hljs-params">self, ticket_info: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 購票的業務邏輯...</span><br>        self.notify_observers(self, **ticket_info)  <span class="hljs-comment"># 通知所有觀察者</span><br><br><br>ticket_office: TicketOffice = TicketOffice()<br>ticket_office.add_observer(EmailNotifier())<br>ticket_office.add_observer(LineNotifier())<br><br>ticket_office.buy_a_ticket(&#123;<br>    <span class="hljs-string">&quot;ticket_name&quot;</span>: <span class="hljs-string">&quot;大港&quot;</span>,<br>    <span class="hljs-string">&quot;ticket_price&quot;</span>: <span class="hljs-number">100</span><br>&#125;)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Email 通知：已成功購買「大港」的票</span><br><span class="hljs-string">Line 通知：已成功購買「大港」的票</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>這時如果廠商要求添加「簡訊通知」的方式，只要增加一個 <code>MessageNotifier(Observer)</code>，並加入到 TicketOffice 實例中的觀察者列表即可。</p><blockquote><p>想要更深入了解 SOLID 原則的人可以參考 <a href="https://duke851230.github.io/2023/08/05/python-oop-solid/">Python 與物件導向（五）：SOLID 原則</a>。</p></blockquote><p>而且這樣添加一個通知方式，並不需要修改購票本身的函數（<strong>符合 SOLID 的開放封閉原則</strong>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MessageNotifier</span>(<span class="hljs-title class_ inherited__">Observer</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">operate</span>(<span class="hljs-params">self, subject: Subject, *args, **kwargs</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-comment"># 簡訊通知的業務邏輯...</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;簡訊通知：已成功購買「<span class="hljs-subst">&#123;kwargs[<span class="hljs-string">&#x27;ticket_name&#x27;</span>]&#125;</span>」的票&quot;</span>)<br><br>ticket_office.add_observer(MessageNotifier())<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Design-Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design-Pattern</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>設計模式：單例模式</title>
    <link href="/2023/10/04/design-pattern-singleton/"/>
    <url>/2023/10/04/design-pattern-singleton/</url>
    
    <content type="html"><![CDATA[<p>接下來要跟大家分享一個也十分常用的創建型設計模式 ──「單例模式」。</p><span id="more"></span><blockquote><p>最後編輯日期：2024&#x2F;01&#x2F;29</p></blockquote><h2 id="什麼是單例模式（Singleton-Pattern）？"><a href="#什麼是單例模式（Singleton-Pattern）？" class="headerlink" title="什麼是單例模式（Singleton Pattern）？"></a>什麼是單例模式（Singleton Pattern）？</h2><p>單例模式是一種<strong>創建型</strong>的設計模式，用於確保<font color=#FF0000><strong>一個類只會產生一個實例</strong></font>。</p><h3 id="單例模式的應用場景："><a href="#單例模式的應用場景：" class="headerlink" title="單例模式的應用場景："></a><font color=#d2691e>單例模式的應用場景：</font></h3><ul><li><p><strong>全局對象：</strong></p><blockquote><p>e.g. 日誌紀錄器、設定檔對象等。</p></blockquote><p>  在程式中，可能有些對象是會要<strong>被全局調用</strong>的。所以為了統一該對象的狀態，我們可以使用「單例模式」來確保該對象在記憶體中是唯一的，並確保所有調用都是指向它。</p></li><li><p><strong>減少創建刪除開銷：</strong></p><blockquote><p>e.g. 資料庫連接等。</p></blockquote><p>  在程式中，對象的創建與銷毀都是需要消耗資源的。所以會希望一些常用對象<strong>不要重複創建</strong>，以減少程式開銷。</p></li></ul><h2 id="單例模式的範例："><a href="#單例模式的範例：" class="headerlink" title="單例模式的範例："></a>單例模式的範例：</h2><blockquote><p>使用單例模式時，需要注意你所使用的實現方式<strong>是否是「線程安全（Thread-safe）」的</strong>。<br>不然可能會遇到在 Single-threading 中可以正常運行，但在 Multi-threading 卻會遇到奇怪的 Bug。</p></blockquote><p>接下來，就來跟大家分享幾個在 Python 中常用來實現單例模式的方式。</p><h3 id="通過導入模塊級的變量實現："><a href="#通過導入模塊級的變量實現：" class="headerlink" title="通過導入模塊級的變量實現："></a><font color=#d2691e>通過導入模塊級的變量實現：</font></h3><blockquote><p>算是一種最為簡單的單例模式。</p></blockquote><p>且在 Python 中，<font color=#FF0000><strong>模塊只會在程序首次導入時執行一次</strong></font>，天然的避免了 <strong>Multi-threading</strong> 的問題（因為不會有多 Thread 同時導入模塊的情況發生）。</p><ul><li>single_class.py：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>    path = <span class="hljs-string">&quot;../&quot;</span><br>    file_name = <span class="hljs-string">&quot;test.txt&quot;</span><br><br>config: Config = Config()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(config))  <span class="hljs-comment"># 139681216760704</span><br></code></pre></td></tr></table></figure></li><li>main.py：<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> single_class <span class="hljs-keyword">import</span> config<br><br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(config))  <span class="hljs-comment"># 139681216760704</span><br></code></pre></td></tr></table></figure></li></ul><h3 id="使用裝飾器來實現："><a href="#使用裝飾器來實現：" class="headerlink" title="使用裝飾器來實現："></a><font color=#d2691e>使用裝飾器來實現：</font></h3><p>在裝飾器外層中，定義一個字典變量來紀錄各個被裝飾類的實例，若已創建過，則不重複創建。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleton</span>(<span class="hljs-params">cls</span>):<br>    _instance = &#123;&#125;<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_instance</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>            _instance[cls] = cls(*args, **kwargs)<br>        <span class="hljs-keyword">return</span> _instance[cls]<br>    <br>    <span class="hljs-keyword">return</span> get_instance<br><br><span class="hljs-meta">@singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>    path = <span class="hljs-string">&quot;../&quot;</span><br>    file_name = <span class="hljs-string">&quot;test.txt&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>) -&gt; <span class="hljs-string">&quot;Config&quot;</span>:<br>        time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 模仿創建開銷</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_config</span>():<br>    obj = Config()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Config id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>(obj)&#125;</span>&quot;</span>) <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    thread = threading.Thread(target=create_config)<br>    thread.start()<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">不適用於 Multi-threading。</span><br><span class="hljs-string">Config id: 140539299780112</span><br><span class="hljs-string">Config id: 140539300278352</span><br><span class="hljs-string">Config id: 140539299883984</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>但這樣不是 Thread-safe 的。因為在多 Thread 的程序中，可能會同時讀取 <code>_instance</code>，導致它們都會認為裡面沒有已創建成功的對應實例，因而重複創建。</p><p>所以這邊透過加上 Thread Lock 來解決：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">singleton</span>(<span class="hljs-params">cls</span>):<br>    _instance = &#123;&#125;<br>    lock = threading.Lock()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_instance</span>(<span class="hljs-params">*args, **kwargs</span>):<br>        <span class="hljs-keyword">with</span> lock:<br>            <span class="hljs-keyword">if</span> cls <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> _instance:<br>                _instance[cls] = cls(*args, **kwargs)<br>            <span class="hljs-keyword">return</span> _instance[cls]<br>        <br>    <span class="hljs-keyword">return</span> get_instance<br><br><span class="hljs-meta">@singleton</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>    path = <span class="hljs-string">&quot;../&quot;</span><br>    file_name = <span class="hljs-string">&quot;test.txt&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>) -&gt; <span class="hljs-string">&quot;Config&quot;</span>:<br>        time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 模仿創建開銷</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">super</span>().__new__(cls, *args, **kwargs)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_config</span>():<br>    obj = Config()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Config id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>(obj)&#125;</span>&quot;</span>) <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    thread = threading.Thread(target=create_config)<br>    thread.start()<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Config id: 139904615765136</span><br><span class="hljs-string">Config id: 139904615765136</span><br><span class="hljs-string">Config id: 139904615765136</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="覆寫-new-來實現："><a href="#覆寫-new-來實現：" class="headerlink" title="覆寫 new() 來實現："></a><font color=#d2691e>覆寫 <strong>new</strong>() 來實現：</font></h3><p><code>__new__()</code> 是用於創建實例的。可以透過在創建前，判斷之前有沒有創建過，來看要不要建立實例對象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>    _instance = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.path = <span class="hljs-string">&quot;../&quot;</span><br>        self.file_name = <span class="hljs-string">&quot;test.txt&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">if</span> cls._instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 模仿創建開銷</span><br>            cls._instance = <span class="hljs-built_in">super</span>(Config, cls).__new__(cls, *args, **kwargs)<br>        <span class="hljs-keyword">return</span> cls._instance<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_config</span>():<br>    obj = Config()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Config id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>(obj)&#125;</span>&quot;</span>) <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    thread = threading.Thread(target=create_config)<br>    thread.start()<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">不適用於 Multi-threading。</span><br><span class="hljs-string">Config id: 140499110178448</span><br><span class="hljs-string">Config id: 140499110178384</span><br><span class="hljs-string">Config id: 140499109800528</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><p>但這同樣不是 Thread-safe 的。因為在多 Thread 的程序中，可能會同時讀取 <code>_instance</code>，導致它們都認為 <code>_instance</code> 為 None，因而重複創建。</p><p>所以這邊透過加上 Thread Lock 來解決：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> threading<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Config</span>:<br>    _instance = <span class="hljs-literal">None</span><br>    lock = threading.Lock()<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.path = <span class="hljs-string">&quot;../&quot;</span><br>        self.file_name = <span class="hljs-string">&quot;test.txt&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__new__</span>(<span class="hljs-params">cls, *args, **kwargs</span>):<br>        <span class="hljs-keyword">with</span> cls.lock:<br>            <span class="hljs-keyword">if</span> cls._instance <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>                time.sleep(<span class="hljs-number">0.5</span>) <span class="hljs-comment"># 模仿創建開銷</span><br>                cls._instance = <span class="hljs-built_in">super</span>(Config, cls).__new__(cls, *args, **kwargs)<br>            <span class="hljs-keyword">return</span> cls._instance<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_config</span>():<br>    obj = Config()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Config id: <span class="hljs-subst">&#123;<span class="hljs-built_in">id</span>(obj)&#125;</span>&quot;</span>) <br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    thread = threading.Thread(target=create_config)<br>    thread.start()<br><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Config id: 139956013674192</span><br><span class="hljs-string">Config id: 139956013674192</span><br><span class="hljs-string">Config id: 139956013674192</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Design-Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design-Pattern</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>設計模式：代理模式</title>
    <link href="/2023/10/03/design-pattern-proxy/"/>
    <url>/2023/10/03/design-pattern-proxy/</url>
    
    <content type="html"><![CDATA[<p>在前兩篇文章裡，我已經跟大家分享了「創建型」與「行為型」模式中的各一種設計模式。所以接下來我要來跟大家分享「結構型」模式之一的代理模式。</p><span id="more"></span><h2 id="什麼是代理模式（Proxy-Pattern）？"><a href="#什麼是代理模式（Proxy-Pattern）？" class="headerlink" title="什麼是代理模式（Proxy Pattern）？"></a>什麼是代理模式（Proxy Pattern）？</h2><blockquote><p>代理模式常會應用在「<strong>不能修改原代碼</strong>」的情況，我們可以透過「代理對象」增加額外操作。</p></blockquote><p>代理模式是一種<strong>結構型</strong>的設計模式。它主要是透過<font color=#FF0000><strong>建立一個「代理對象」，來控制對「原對象」的訪問</strong></font>，且我們可以在訪問原對象前後添加一些額外處理。</p><h3 id="代理模式中的角色："><a href="#代理模式中的角色：" class="headerlink" title="代理模式中的角色："></a><font color=#d2691e>代理模式中的角色：</font></h3><ul><li><strong>Subject（抽象對象介面）：</strong>定義了真實對象和代理對象的共同接口。</li><li><strong>Real Subject（真實對象）：</strong>在代理模式中<strong>被代理的對象</strong>，為真正被訪問的原對象。</li><li><strong>Proxy（代理對象）：</strong>代理對象<strong>持有對真實對象的引用</strong>，在執行真實對象的前後，可以添加一些額外的處理。</li></ul><h3 id="代理模式的應用場景："><a href="#代理模式的應用場景：" class="headerlink" title="代理模式的應用場景："></a><font color=#d2691e>代理模式的應用場景：</font></h3><ol><li><p><strong>遠程代理：</strong></p><p> 當目標對象存在於<strong>不同的地址空間或需要網絡訪問</strong>時，可以使用遠程代理。遠程代理就像一個<font color=#FF0000><strong>中間人</strong></font>，將客戶端的請求轉發給遠程的目標對象，並將結果返回給客戶端。<br> e.g. 像是分布式系統間的通信。</p></li><li><p><strong>虛擬代理：</strong></p><p> 當創建目標對象的過程較為<strong>耗時</strong>時，可以使用代理模式提供一個替代的虛擬對象，並<strong>在真正要使用時才實例化目標對象</strong>，實現「<font color=#FF0000><strong>延遲加載</strong></font>」。<br> e.g. 常用於對圖片、音頻或文件等大型資源的處理。</p></li><li><p><strong>安全代理：</strong></p><p> 安全代理可以用於控制對目標對象的<strong>訪問權限</strong>，可以在調用目標對象之前進行驗證，以確保客戶端具有足夠的權限進行操作。</p></li><li><p><strong>日誌記錄代理：</strong></p><p> 在調用目標對象的方法前後執行額外的日誌記錄操作，例如記錄方法的輸入參數、返回值或執行時間等。</p></li></ol><h2 id="代理模式範例："><a href="#代理模式範例：" class="headerlink" title="代理模式範例："></a>代理模式範例：</h2><h3 id="日誌紀錄代理："><a href="#日誌紀錄代理：" class="headerlink" title="日誌紀錄代理："></a><font color=#d2691e>日誌紀錄代理：</font></h3><p>我們實際使用的是 <code>FileHandlerProxy</code>。而 <code>FileHandlerProxy</code> 會幫我們去調用 <code>FileHandler</code> 的對應功能，並額外添加一些日誌信息。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCFileHandler</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, file_path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandler</span>(<span class="hljs-title class_ inherited__">ABCFileHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, file_path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        f = <span class="hljs-built_in">open</span>(file_path, <span class="hljs-string">&quot;r&quot;</span>)<br>        <span class="hljs-keyword">return</span> f.read()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileHandlerProxy</span>(<span class="hljs-title class_ inherited__">ABCFileHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, real_subject: ABCFileHandler</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._real_subject: ABCFileHandler = real_subject<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">self, file_path: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(Debug) file_path: <span class="hljs-subst">&#123;file_path&#125;</span>&quot;</span>)<br>        res: <span class="hljs-built_in">str</span> = self._real_subject.read(file_path)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;(Debug) result: \n<span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> res<br><br>proxy: FileHandlerProxy = FileHandlerProxy(<br>    real_subject=FileHandler()<br>)<br>proxy.read(<span class="hljs-string">&quot;./time.txt&quot;</span>)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">(Debug) file_path: ./time.txt</span><br><span class="hljs-string">(Debug) result: </span><br><span class="hljs-string">2023-01-01T00:00:00</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h3 id="虛擬代理："><a href="#虛擬代理：" class="headerlink" title="虛擬代理："></a><font color=#d2691e>虛擬代理：</font></h3><p>這邊主要是實現了兩個作用：</p><ol><li>延遲加載：當我們實例化 <code>ProxyImageHandler</code> 時，其實不會像直接使用 <code>ImageHandler</code> 一樣，立馬去讀取圖片。而是等我們明確調用 <code>ProxyImageHandler().display()</code> 時才會去加載。</li><li>緩存圖片：只有當我們<strong>第一次</strong>去調用 <code>ProxyImageHandler().display()</code> 時，才會去創建 <code>ImageHandler</code> 對象，之後都是使用記憶體中的對象。</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><span class="hljs-keyword">from</span> PIL <span class="hljs-keyword">import</span> Image<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCImageHandler</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_image_from_disk</span>(<span class="hljs-params">self</span>) -&gt; Image.Image:<br>        <span class="hljs-keyword">pass</span><br>    <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">pass</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ImageHandler</span>(<span class="hljs-title class_ inherited__">ABCImageHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._filename: <span class="hljs-built_in">str</span> = filename<br>        self._image: Image.Image = self.load_image_from_disk()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_image_from_disk</span>(<span class="hljs-params">self</span>) -&gt; Image.Image:<br>        img: Image.Image = Image.<span class="hljs-built_in">open</span>(self._filename)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Load image <span class="hljs-subst">&#123;self._filename&#125;</span> from disk.&quot;</span>)<br>        <span class="hljs-keyword">return</span> img<br>        <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Display image: <span class="hljs-subst">&#123;self._filename&#125;</span>\n&quot;</span>)<br>        self._image.show()<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProxyImageHandler</span>(<span class="hljs-title class_ inherited__">ABCImageHandler</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, filename: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._filename: <span class="hljs-built_in">str</span> = filename<br>        self._real_subject: <span class="hljs-type">Optional</span>[ImageHandler] = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_image_from_disk</span>(<span class="hljs-params">self</span>) -&gt; Image.Image:<br>        <span class="hljs-keyword">if</span> self._real_subject <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._real_subject = ImageHandler(self._filename)<br>        <span class="hljs-keyword">return</span> self._real_subject.po()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">if</span> self._real_subject <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            self._real_subject = ImageHandler(self._filename)<br>        self._real_subject.display()<br><br>img: ProxyImageHandler = ProxyImageHandler(filename=<span class="hljs-string">&quot;./img.png&quot;</span>)<br><br><span class="hljs-comment"># 第一次顯示圖片時，真實圖像對象才會被創建並加載圖片</span><br>img.display()<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Load image ./img.png from disk.</span><br><span class="hljs-string">Display image: ./img.png</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>time.sleep(<span class="hljs-number">1</span>)<br><br>img.display()<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Display image: ./img.png</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Design-Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design-Pattern</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>設計模式：策略模式</title>
    <link href="/2023/10/02/design-pattern-strategy/"/>
    <url>/2023/10/02/design-pattern-strategy/</url>
    
    <content type="html"><![CDATA[<p>繼上一篇「工廠模式」之後，我再來跟大家分享一個我也蠻常使用的模式 ──「策略模式」。</p><span id="more"></span><h2 id="什麼是策略模式（Strategy-Pattern）？"><a href="#什麼是策略模式（Strategy-Pattern）？" class="headerlink" title="什麼是策略模式（Strategy Pattern）？"></a>什麼是策略模式（Strategy Pattern）？</h2><blockquote><p>行為型模式用於解耦程序運行途中的「複雜流程控制」。<br>透過描述多個對象間的互動，且各對象都有各自的職責分配，以便程式更易擴展與修改。</p></blockquote><p>策略模式是一種<strong>行為型</strong>的設計模式，它主要是將「<font color=#FF0000><strong>複雜的算法</strong></font>」與「<font color=#FF0000><strong>使用</strong></font>」解耦。<br>透過將算法封裝在個別的算法模組中，之後使用時只要替換對應的算法模組即可，不影響其他程式的結構。</p><h3 id="策略模式中的角色："><a href="#策略模式中的角色：" class="headerlink" title="策略模式中的角色："></a><font color=#d2691e>策略模式中的角色：</font></h3><p>在之後的程式中，我們可透過替換不同的「具體策略」，來達到不同的行為結果。</p><ul><li><strong>抽象策略：</strong>定義策略類別的公共接口，通常會聲明算法的操作方法。</li><li><strong>具體策略：</strong>實現了抽象策略的具體類別。</li><li><strong>Context 環境類：</strong>像是一個可使用不同策略的<font color=#FF0000><strong>容器</strong></font>。可根據需要，切換不同策略，且不影響容器本身的結構。</li></ul><h3 id="以白話文來解釋策略模式的角色："><a href="#以白話文來解釋策略模式的角色：" class="headerlink" title="以白話文來解釋策略模式的角色："></a><font color=#d2691e>以白話文來解釋策略模式的角色：</font></h3><p>假設有一個遊戲角色，這個角色可以根據做出不同攻擊來對敵人造成不同傷害，例如普通攻擊、特殊攻擊、大絕等。<br>而其中角色就是指「Context」；普通攻擊、特殊攻擊、大絕等則是指不同的「Strategy」。</p><p>這樣在遊戲運行時，就可以透過<strong>動態選擇</strong>不同攻擊，來對敵人造成不同傷害結果，而不需修改角色本身的程式碼。<br>所以只要我們在 Context 中做好對 Strategy 的正確引用，就可透過調用不同 Strategy 來實現不同的行為。這使得程式碼更容易擴展，因為不必一再修改 Context 的原始碼。</p><h2 id="策略模式範例："><a href="#策略模式範例：" class="headerlink" title="策略模式範例："></a>策略模式範例：</h2><p>使用策略模式後，我們就可以在<strong>不修改 <code>Calculator</code> 類程式碼</strong>的情況下替換策略，從而實現不同的計算操作。</p><ul><li>要新增除法時，只要新增一個除法具體策略即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCStrategy</span>(<span class="hljs-title class_ inherited__">ABC</span>):  <span class="hljs-comment"># 抽象策略</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">float</span>, num2: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AdditionStrategy</span>(<span class="hljs-title class_ inherited__">ABCStrategy</span>):  <span class="hljs-comment"># 具體策略</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">float</span>, num2: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> num1 + num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">SubtractionStrategy</span>(<span class="hljs-title class_ inherited__">ABCStrategy</span>):  <span class="hljs-comment"># 具體策略</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">float</span>, num2: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> num1 - num2<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiplicationStrategy</span>(<span class="hljs-title class_ inherited__">ABCStrategy</span>):  <span class="hljs-comment"># 具體策略</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">execute</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">float</span>, num2: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> num1 * num2<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Calculator</span>:  <span class="hljs-comment"># Context，實際去調用算法的代理人</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, strategy: ABCStrategy</span>):<br>        self._strategy = strategy<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strategy</span>(<span class="hljs-params">self</span>) -&gt; ABCStrategy:<br>        <span class="hljs-keyword">return</span> self._strategy<br>    <br><span class="hljs-meta">    @strategy.setter</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">strategy</span>(<span class="hljs-params">self, strategy: ABCStrategy</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self._strategy = strategy<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, num1: <span class="hljs-built_in">float</span>, num2: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> self._strategy.execute(num1, num2)<br><br><br>calculator = Calculator(AdditionStrategy())<br><span class="hljs-built_in">print</span>(calculator.calculate(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 輸出: 8</span><br><br>calculator.strategy = SubtractionStrategy()<br><span class="hljs-built_in">print</span>(calculator.calculate(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 輸出: 2</span><br><br>calculator.strategy = MultiplicationStrategy()<br><span class="hljs-built_in">print</span>(calculator.calculate(<span class="hljs-number">5</span>, <span class="hljs-number">3</span>))  <span class="hljs-comment"># 輸出: 15</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Design-Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design-Pattern</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>設計模式：工廠模式</title>
    <link href="/2023/10/01/design-pattern-factory/"/>
    <url>/2023/10/01/design-pattern-factory/</url>
    
    <content type="html"><![CDATA[<p>大家寫程式時，可能會常常聽到「Design Pattern」，但可能不太清楚這是什麼，所以我接下來將一步步介紹一些我平時會用到的設計模式。</p><span id="more"></span><h2 id="為什麼需要學習這個酷東西呢？"><a href="#為什麼需要學習這個酷東西呢？" class="headerlink" title="為什麼需要學習這個酷東西呢？"></a>為什麼需要學習這個酷東西呢？</h2><blockquote><p>關於 SOLID 原則，可以參考我之前的文章：<a href="https://duke851230.github.io/2023/08/05/python-oop-solid/">Python 與物件導向（五）：SOLID 原則</a></p></blockquote><p>在之前的文章中，我們有提到過「SOLID 原則」，大家可能會遇到一種情況：這些概念我都知道了，但我還是不知道如何轉成程式碼？如何去應用？<br>這時有幾位大大幫我們統整了二十幾種的程式設計模式，這些模式其實大多也都會貼合「SOLID 原則」，所以我們可以透過從這些模式中借鑒，讓我們可以更好應用在工作上。</p><h2 id="簡單介紹一下-Design-Pattern："><a href="#簡單介紹一下-Design-Pattern：" class="headerlink" title="簡單介紹一下 Design Pattern："></a>簡單介紹一下 Design Pattern：</h2><p>在程式設計中，經常會遇到類似的設計問題。而隨著時間推進，這些設計問題被統整歸類，進而發展出了 Design Pattern，讓我們可以<strong>針對這些反覆出現的問題，找出一個較通用的解決方案</strong>。</p><p>Design Pattern 書中一共提到了 23 種設計模式，根據使用情境它們被分成了三大類：「創建型」、「結構型」、「行為型」。</p><h3 id="Design-Pattern-的核心作用："><a href="#Design-Pattern-的核心作用：" class="headerlink" title="Design Pattern 的核心作用："></a><font color=#d2691e>Design Pattern 的核心作用：</font></h3><p><font color=#6495ed><strong>降低耦合性：</strong></font><br>盡量降低類別或對象之間的依賴關係。使<strong>各部分可以獨立修改和擴展，而不會影響其他部分</strong>。</p><p><font color=#6495ed><strong>提高程式碼的可讀性：</strong></font><br>使用常見的設計模式，可以<strong>讓程式碼更易於理解</strong>，因為如果其他開發者也熟悉這些模式，便能更快地理解程式碼的意圖。</p><h2 id="工廠模式（Factory-Pattern）："><a href="#工廠模式（Factory-Pattern）：" class="headerlink" title="工廠模式（Factory Pattern）："></a>工廠模式（Factory Pattern）：</h2><p>工廠模式是屬於創建型的設計模式。<br>創建型的目的是在於<strong>讓「創建」與「使用」解耦</strong>，並<strong>隱藏創建細節</strong>，讓「創建邏輯」與「業務邏輯」分離。</p><blockquote><p>這三種模式可以理解為同種設計理念的三個版本，根據它解決的問題從簡單到困難不斷升級。</p></blockquote><p>工程模式其實根據用法可以再細分成「簡單工廠」、「工廠方法」、「抽象工廠」三種模式。</p><h3 id="工廠模式的角色："><a href="#工廠模式的角色：" class="headerlink" title="工廠模式的角色："></a><font color=#d2691e>工廠模式的角色：</font></h3><p>通常工廠模式中會有兩種實體角色，也就是「工廠（Factory）」和「產品（Product）」，我們使用者只會透過工廠去幫忙生成我們要的產品，而<strong>不會參與到產品的構建（使用者不會直接去實例化產品對象）</strong>。</p><ul><li>實體工廠</li><li>實體產品</li><li>抽象工廠：聲明了創建產品的抽象方法的接口。</li><li>抽象產品：聲明了產品的共同屬性和抽象方法的接口。</li></ul><h2 id="工廠模式實例："><a href="#工廠模式實例：" class="headerlink" title="工廠模式實例："></a>工廠模式實例：</h2><h3 id="簡單工廠模式："><a href="#簡單工廠模式：" class="headerlink" title="簡單工廠模式："></a><font color=#d2691e>簡單工廠模式：</font></h3><p>簡單工廠做的事很簡單，就是單純讓「創建」與「使用」解耦。讓使用者透過<font color=#FF0000><strong>單一的工廠類別</strong></font>，並<strong>根據不同的參數</strong>來創建不同的產品對象。</p><p><font color=#6495ed><strong>程式結構：</strong></font></p><ul><li>只有一個工廠類，工廠類會根據參數傳遞的參數，來創建具體的產品對象</li><li>通常會定義一個<strong>抽象產品類</strong>，來約束各產品類</li></ul><p><font color=#6495ed><strong>程式範例：</strong></font></p><blockquote><p>但缺點就是我們每新增一個產品類別，就要去修改工廠類別的條件判斷式，不符合「開放封閉原則」。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apparel</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clothes</span>(<span class="hljs-title class_ inherited__">Apparel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Clothes&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pants</span>(<span class="hljs-title class_ inherited__">Apparel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pants&quot;</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ApparelFactory</span>:<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_product</span>(<span class="hljs-params">cls, product_type: <span class="hljs-built_in">str</span></span>) -&gt; Apparel:<br>        <span class="hljs-keyword">if</span> product_type == <span class="hljs-string">&quot;clothes&quot;</span>:<br>            <span class="hljs-keyword">return</span> Clothes()<br>        <span class="hljs-keyword">elif</span> product_type == <span class="hljs-string">&quot;pants&quot;</span>:<br>            <span class="hljs-keyword">return</span> Pants()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&quot;Invalid product type.&quot;</span>)<br><br><br>clothes: Apparel = ApparelFactory.create_product(<span class="hljs-string">&quot;clothes&quot;</span>)<br><span class="hljs-built_in">print</span>(clothes.display())  <span class="hljs-comment"># Clothes</span><br><br>pants: Apparel = ApparelFactory.create_product(<span class="hljs-string">&quot;pants&quot;</span>)<br><span class="hljs-built_in">print</span>(pants.display())  <span class="hljs-comment"># Pants</span><br></code></pre></td></tr></table></figure><h3 id="工廠方法模式："><a href="#工廠方法模式：" class="headerlink" title="工廠方法模式："></a><font color=#d2691e>工廠方法模式：</font></h3><p>主要是為了解決簡單工廠沒有符合「開放封閉原則」的問題，讓我們在新增產品類別時，不必更改舊程式。</p><p><font color=#6495ed><strong>程式結構：</strong></font></p><ul><li>將簡單工廠拆分成多工廠，各工廠只會負責自己的產品</li><li>透過定義一個抽象工廠類別，增加<strong>多個實體工廠類別分別負責創建不同的實體產品</strong></li></ul><p><font color=#6495ed><strong>程式範例：</strong></font></p><blockquote><p>但這樣還是有個小缺點，就是不能應對二級分類的產品。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod, abstractclassmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Apparel</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Clothes</span>(<span class="hljs-title class_ inherited__">Apparel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Clothes&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Pants</span>(<span class="hljs-title class_ inherited__">Apparel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Pants&quot;</span><br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCFactory</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractclassmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_product</span>(<span class="hljs-params">cls</span>) -&gt; Apparel:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClothesFactory</span>(<span class="hljs-title class_ inherited__">ABCFactory</span>):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_product</span>(<span class="hljs-params">cls</span>) -&gt; Apparel:<br>        <span class="hljs-keyword">return</span> Clothes()<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PantsFactory</span>(<span class="hljs-title class_ inherited__">ABCFactory</span>):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_product</span>(<span class="hljs-params">cls</span>) -&gt; Apparel:<br>        <span class="hljs-keyword">return</span> Pants()<br><br><br>clothes: Apparel = ClothesFactory.create_product()<br><span class="hljs-built_in">print</span>(clothes.display())  <span class="hljs-comment"># Clothes</span><br><br>pants: Apparel = PantsFactory.create_product()<br><span class="hljs-built_in">print</span>(pants.display())  <span class="hljs-comment"># Pants</span><br></code></pre></td></tr></table></figure><h3 id="抽象工廠模式："><a href="#抽象工廠模式：" class="headerlink" title="抽象工廠模式："></a><font color=#d2691e>抽象工廠模式：</font></h3><blockquote><p>舉例一下「二級分類」，顧名思義就是會有兩層結構的分類。如一個服裝工廠能同時生產褲子、衣服：</p><ul><li>褲子、衣服屬於一級分類</li><li>所有服裝又可分為男版和女版，這屬於二級分類</li></ul></blockquote><p>主要是解決前兩者無法對「二級分類」產品構建的問題。</p><p><font color=#6495ed><strong>程式結構：</strong></font></p><ul><li>工廠會以<strong>二級分類</strong>來命名，有幾個二級分類，就會有幾個工廠類</li><li>工廠類中會有不同的<strong>一級分類產品的構造方法</strong>，有幾個一級分類，工廠類中就會有幾個函數</li></ul><p><font color=#6495ed><strong>程式範例：</strong></font></p><blockquote><p>缺點就是程式會有點複雜，其實我本身也不太會用。<br>且如果是更多級的分類，工廠類就會更複雜，比如說三級分類的工廠就會長的像 FactoryCategory1Type1 之類的。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><code class="hljs Python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod, abstractclassmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ClothesABC</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManClothes</span>(<span class="hljs-title class_ inherited__">ClothesABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ManClothes&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WomanClothes</span>(<span class="hljs-title class_ inherited__">ClothesABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WomanClothes&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PantsABC</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManPants</span>(<span class="hljs-title class_ inherited__">PantsABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;ManPants&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WomanPants</span>(<span class="hljs-title class_ inherited__">PantsABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">display</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">str</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;WomanPants&quot;</span><br>    <br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ABCFactory</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractclassmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_clothes</span>(<span class="hljs-params">cls</span>) -&gt; ClothesABC:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">    @abstractclassmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_pants</span>(<span class="hljs-params">cls</span>) -&gt; PantsABC:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ManFactory</span>(<span class="hljs-title class_ inherited__">ABCFactory</span>):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_clothes</span>(<span class="hljs-params">cls</span>) -&gt; ClothesABC:<br>        <span class="hljs-keyword">return</span> ManClothes()<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_pants</span>(<span class="hljs-params">cls</span>) -&gt; PantsABC:<br>        <span class="hljs-keyword">return</span> ManPants()<br>    <br><span class="hljs-keyword">class</span> <span class="hljs-title class_">WomanFactory</span>(<span class="hljs-title class_ inherited__">ABCFactory</span>):<br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_clothes</span>(<span class="hljs-params">cls</span>) -&gt; ClothesABC:<br>        <span class="hljs-keyword">return</span> WomanClothes()<br>    <br><span class="hljs-meta">    @classmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">create_pants</span>(<span class="hljs-params">cls</span>) -&gt; PantsABC:<br>        <span class="hljs-keyword">return</span> WomanPants()<br><br><br><span class="hljs-built_in">print</span>(ManFactory.create_clothes().display())  <span class="hljs-comment"># ManClothes</span><br><span class="hljs-built_in">print</span>(ManFactory.create_pants().display())  <span class="hljs-comment"># ManPants</span><br><span class="hljs-built_in">print</span>(WomanFactory.create_clothes().display())  <span class="hljs-comment"># WomanClothes</span><br><span class="hljs-built_in">print</span>(WomanFactory.create_pants().display())  <span class="hljs-comment"># WomanPants</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Design-Pattern</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Design-Pattern</tag>
      
      <tag>OOP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（六）：繼承 vs 組合</title>
    <link href="/2023/08/06/python-oop-inheritance-composition/"/>
    <url>/2023/08/06/python-oop-inheritance-composition/</url>
    
    <content type="html"><![CDATA[<p>在前面的文章中，可能都有隱約提到「濫用繼承」會造成程式碼難以維護。所以這邊將提供另外一種思考模式，讓我們可以寫出易於擴展的程式碼！</p><span id="more"></span><h2 id="先來個簡單介紹："><a href="#先來個簡單介紹：" class="headerlink" title="先來個簡單介紹："></a>先來個簡單介紹：</h2><p>可能你們常常會聽到有人在說「<strong>少用繼承，多用組合</strong>」或是「<strong>以組合代替繼承</strong>」。<br>那究竟什麼是繼承？什麼是組合呢？其實它們都是用來描述<strong>類別之間的關係</strong>，只是思考的方式不同而已。</p><h3 id="繼承（inheritance）："><a href="#繼承（inheritance）：" class="headerlink" title="繼承（inheritance）："></a><font color=#d2691e>繼承（inheritance）：</font></h3><blockquote><p>繼承是一種 <strong><code>is-a</code></strong> 的關係。<br>若想要更加深入，可以參考我的另一篇文章：<a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a>。</p></blockquote><p>繼承之前已經有介紹過了，這邊就只簡單的講講概念。<br>如果用現實世界來舉例，我們會說「吉普車」是一種「車」，這就是一種<strong>「<code>is-a</code>」</strong>的思考模式。在程式中我們就會定義一個名為「車」的父類別，然後可以透過繼承去實現多個子類，如「吉普車」、「跑車」等。</p><h3 id="組合（composition）："><a href="#組合（composition）：" class="headerlink" title="組合（composition）："></a><font color=#d2691e>組合（composition）：</font></h3><blockquote><p>組合是一種 <strong><code>has-a</code></strong> 的關係。</p></blockquote><p>組合則是一種比較複雜的思考方式。以上述繼承的例子來說，我們就不會再把「車」當成一個完整的實體，而是會將它拆解成「輪子」、「引擎」、「板金」等等，然後再把它們當成零件，組成一台車子。</p><p>在程式中也是如此，<strong>組合就是指將一個類別的物件作為另一個類別的屬性</strong>，也就是說，一個類別會包含多個其他類別的物件。如果還是不清楚的話沒關係，我們來看看一個簡單的例子。</p><h4 id="簡單範例："><a href="#簡單範例：" class="headerlink" title="簡單範例："></a><font color=#6495ed><strong>簡單範例：</strong></font></h4><blockquote><p>我們這邊先假設「車子」只會有「輪子」和「引擎」兩個零件，不然真的太多了XD</p></blockquote><p>假設我們現在要建一個「吉普車」類，我們就會先想吉普車可能會有大顆的輪子和較有力的引擎，因為要拿來跑比較崎嶇的地形。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Wheel</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Engine</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BigWheel</span>(<span class="hljs-title class_ inherited__">Wheel</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">rotate</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;用大輪子跑跑跑&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PowerfulEngine</span>(<span class="hljs-title class_ inherited__">Engine</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">start</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;引擎啟動！&quot;</span>)<br></code></pre></td></tr></table></figure><p>有了零件之後，我們就能來建「吉普車」了。透過將零件當作「吉普車」的屬性來插入，就能建造出獨一無二的吉普車了。</p><p>這樣的好處是如果「跑車」也要用到我們的 <code>PowerfulEngine</code>，它就能直接拿去用，減少重複的代碼。而且因為我們的零件是在要建立車子時才選擇，而不是直接寫死，這樣能降低類別間的耦合，也利於擴展。</p><blockquote><p>這有沒有覺得熟悉，這就是開放封閉原則的「對擴展開放，對修改封閉」。想要深入了解可以參考另一篇文章：<a href="https://duke851230.github.io/2023/08/05/python-oop-solid/">Python 與物件導向（五）：SOLID 原則</a>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Jeep</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, wheel: Wheel, engine: Engine</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.__whell: Wheel = wheel<br>        self.__engine: Engine = engine<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.__engine.start()<br>        self.__whell.rotate()<br><br><br>jeep: Jeep = Jeep(wheel=BigWheel(), engine=PowerfulEngine())<br>jeep.run()<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">引擎啟動！</span><br><span class="hljs-string">用大輪子跑跑跑</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h2 id="繼承與組合的優缺點："><a href="#繼承與組合的優缺點：" class="headerlink" title="繼承與組合的優缺點："></a>繼承與組合的優缺點：</h2><h3 id="繼承（inheritance）：-1"><a href="#繼承（inheritance）：-1" class="headerlink" title="繼承（inheritance）："></a><font color=#d2691e>繼承（inheritance）：</font></h3><h4 id="優點："><a href="#優點：" class="headerlink" title="優點："></a><font color=#6495ed><strong>優點：</strong></font></h4><ol><li>使用起來<strong>較為直覺</strong>，因為繼承是我們一般腦迴路的思考模式。</li><li>能簡單的<strong>重用代碼</strong>，子類會繼承父類的屬性和方法。</li><li>可以輕易對父類別進行<strong>擴充</strong>，子類別可以添加父類沒有的新方法。</li><li>可以實現程式的多態性（也就是多型）。<br>想進一步了解「多型」的朋友，可以參考之前的文章：<a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a>。</li></ol><h4 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a><font color=#6495ed><strong>缺點：</strong></font></h4><ol><li><strong>子類跟父類間高度耦合</strong>。要是父類改動了，所有子類也必須改變，導致維護成本較高。</li><li>行為在<strong>編譯時期</strong>的時候就已經決定，<strong>無法動態改變</strong>。</li><li>在單一繼承的語言中，可能會受到限制。</li></ol><h3 id="組合（composition）：-1"><a href="#組合（composition）：-1" class="headerlink" title="組合（composition）："></a><font color=#d2691e>組合（composition）：</font></h3><h4 id="優點：-1"><a href="#優點：-1" class="headerlink" title="優點："></a><font color=#6495ed><strong>優點：</strong></font></h4><ol><li>由於組合通常會<strong>透過介面來約束各零件的功能</strong>，所以能維持功能的一致性。</li><li>可在<strong>執行期間</strong>替換零件，只要該零件實現了對應介面即可。</li><li>類別的層次不會像繼承那樣，容易深度增長到一個無法管理的境界，<strong>較易維護</strong>。</li><li>每個零件都是專注完成自己的功能，因此更加<strong>內聚</strong>。且與主類別的關係皆為<strong>低耦合</strong>。</li></ol><h4 id="缺點：-1"><a href="#缺點：-1" class="headerlink" title="缺點："></a><font color=#6495ed><strong>缺點：</strong></font></h4><ol><li>需要寫較多的程式碼，增加程式的複雜性。</li></ol>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（五）：SOLID 原則</title>
    <link href="/2023/08/05/python-oop-solid/"/>
    <url>/2023/08/05/python-oop-solid/</url>
    
    <content type="html"><![CDATA[<p>接下來就來跟大家分享大名鼎鼎的 SOLID 原則，讓我們可以少寫出富含臭味的程式碼。</p><span id="more"></span><h2 id="先來講講為什麼我們需要-SOLID-原則？"><a href="#先來講講為什麼我們需要-SOLID-原則？" class="headerlink" title="先來講講為什麼我們需要 SOLID 原則？"></a>先來講講為什麼我們需要 SOLID 原則？</h2><blockquote><p>大家有興趣可以參考我之前的文章：<br><a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a><br><a href="https://duke851230.github.io/2023/08/03/python-oop-override-overload/">Python 與物件導向（三）：覆寫與多載</a></p></blockquote><p>在前面的文章中，已經跟大家介紹了物件導向的基本特性。但僅僅知道如何使用是沒有用的，真的難的是怎麼利用這些特性寫出人人稱羨的 Clean Code。</p><p>最常見臭味四溢的程式碼就是<strong>濫用繼承</strong>。假設我們的程式會是一連串的繼承（父類 -&gt; 子類 -&gt; 孫子類…），這樣如果一改動父類的程式，就會造成一連串的連鎖效應，所有繼承父類的程式都會受到影響，這聽起來是不是臭味滿滿呢XD</p><blockquote><p>SOLID 原則就是大神們統整出來的五大心法，只要牢記這些心法去寫程式，至少能寫出不太臭的程式。</p></blockquote><p>所謂<strong>乾淨的程式碼是要做到「可容忍需求變化」且「易於理解」</strong>，這說起來簡單，但實際要做到還真的不容易。大家有沒有遇過客戶的需求突然改變的情況，如果我們一開始沒有做好「<strong>程式設計</strong>」，之後修改需求時就很像在修補衣服，東補一塊西補一塊，全部程式都攪在一起。</p><h2 id="單一職責原則（Single-Responsibility-Principle）："><a href="#單一職責原則（Single-Responsibility-Principle）：" class="headerlink" title="單一職責原則（Single Responsibility Principle）："></a>單一職責原則（Single Responsibility Principle）：</h2><blockquote><p>這些原則不只適用於類別，像是 Module、Function 也都適用，只是<strong>職責的範圍規模不同</strong>而已。</p></blockquote><p>從字面上來看，SRP 原則就是說<strong>一個類別只負責一個「職責」</strong>，避免將過多職責寫在同一類別。這樣說你們可能還是有點模糊，但如果想成<font color=#FF0000><strong>一個類別只能有一個被修改的理由</strong></font>，可能就更加明確了。</p><h3 id="簡單範例："><a href="#簡單範例：" class="headerlink" title="簡單範例："></a><font color=#d2691e>簡單範例：</font></h3><blockquote><p>這邊用函數來舉例。</p></blockquote><p>假設 <code>create_a_order()</code> 要做兩件事：「資料庫紀錄訂單資訊」、「寄訂單資訊給買家」。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_a_order</span>(<span class="hljs-params">order: <span class="hljs-built_in">dict</span></span>):<br>    <span class="hljs-comment"># 資料庫新增一筆訂單</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Create a order record&quot;</span>)<br><br>    <span class="hljs-comment"># 寄訂單資訊給買家</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Send email to customer&quot;</span>)<br></code></pre></td></tr></table></figure><p>這很明顯違反了 SRP 原則，因為被修改的理由不只一個：</p><ol><li>資料庫原本沒有紀錄買家資訊，現在要紀錄 &#x3D;&gt; 這會動到「資料庫紀錄訂單資訊」</li><li>原本是用 Email 聯繫買家，現在要改用簡訊 &#x3D;&gt; 這會動到「寄訂單資訊給買家」</li></ol><p>所以我們應該將它拆解，讓一個函數只負責做一件事。例如用 <code>create_a_order_record()</code> 來處理資料庫新增紀錄，<code>send_order_info_to_customer()</code> 來負責寄信聯絡買家。而 <code>create_a_order()</code> 本身則只用來做流程控制，<strong>這樣每個函數都只有一個被修改的理由</strong>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_a_order</span>(<span class="hljs-params">order: <span class="hljs-built_in">dict</span></span>):<br>    create_a_order_record(order)<br>    send_order_info_to_customer(order[<span class="hljs-string">&quot;customer_email&quot;</span>], order)<br>    <br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_a_order_record</span>(<span class="hljs-params">order: <span class="hljs-built_in">dict</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Create a order record&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">send_order_info_to_customer</span>(<span class="hljs-params">email: <span class="hljs-built_in">str</span>, order: <span class="hljs-built_in">dict</span></span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Send email to customer&quot;</span>)<br></code></pre></td></tr></table></figure><p>現在可能很多人會在想：函數不是為了用來消除重複的程式碼嗎？我切出來那麼多不可重複用的函數有什麼意義？<br>其實消除重複的程式碼只是其中一個作用而已。抽出函數更重要的是為了要<strong>「<font color=#FF0000>封裝程式邏輯</font>」</strong>，讓單一函數更<strong>單純、內聚</strong>，這樣 Debug 時就能更容易的鎖定問題所在。</p><h2 id="開放封閉原則（Open-Close-Principle）："><a href="#開放封閉原則（Open-Close-Principle）：" class="headerlink" title="開放封閉原則（Open-Close Principle）："></a>開放封閉原則（Open-Close Principle）：</h2><p>軟體實體（模組、類別、函數）都應該<font color=#FF0000><strong>對擴展開放，而對修改封閉</strong></font>。意思是在說當需求變更時，應該是要透過<strong>新增程式碼來取代原有模組，而不是直接更改原有的程式碼</strong>。</p><h3 id="什麼是修改？什麼是擴展？"><a href="#什麼是修改？什麼是擴展？" class="headerlink" title="什麼是修改？什麼是擴展？"></a><font color=#d2691e>什麼是修改？什麼是擴展？</font></h3><p>用現實世界來舉例，假設我們現在筆電鍵盤不好用。如果是直接把筆電鍵盤的鍵帽拔掉換成新的，這就是修改；如果我們是買一個機械式鍵盤並透過 USB 外接，這就是擴展。</p><p>那直接拔鍵帽換新的不是很方便又便宜嗎？為什麼還要花大錢買一個新鍵盤？<br>那是因為你沒想過換鍵帽的<strong>副作用</strong>，假設你在拔鍵帽時不小心用壞了下面的電路，這樣可能會影響到其他元件的運作。但如果我們是用新鍵盤來外接，就不會動到原有的元件了，更加安全穩定。</p><p>在程式中也是一樣，你不會知道你接手的程式有多少奇怪的邏輯包含在其中。如果我們隨便更改，很容易造成<strong>修好了 A，卻用壞了 B 的窘境</strong>，所以為了要寫出好擴展的程式碼，我們就需要將程式「<strong>模組化</strong>」。</p><blockquote><p>而上述的筆電例子是如何做到「模組化」的呢？就是要預留「<strong>擴充點</strong>」，也就是 USB 接口，讓我們能外接鍵盤。</p></blockquote><p>所以我們寫程式也是如此，盡量將程式模組化。每個模組都透過預留的「<strong>對外接口</strong>」插入其他模組來運行，這樣需求改變時，我們只要根據規範定義出另一個模組就能插入「對外接口」來使用了。</p><p>聽到定義規範大家有沒有很熟悉？沒錯就是利用我們之前所講的「抽象類別」與「介面」。大家可以參考之前的文章：<a href="https://duke851230.github.io/2023/08/04/python-oop-abstract-interface/">Python 與物件導向（四）：抽象類別與介面</a>。</p><h3 id="簡單範例：-1"><a href="#簡單範例：-1" class="headerlink" title="簡單範例："></a><font color=#d2691e>簡單範例：</font></h3><blockquote><p>我們常聽到的「策略模式」就是利用了開放封閉原則原則，所以這邊用一個簡單的策略模式程式來舉例。</p></blockquote><p><code>calculate_two_float()</code> 是我的主要程式，且它預留了一個擴充點（<code>operator</code> 參數）來讓我們插入運算子。這樣如果需求改變，像是要改用除法，我只要在新增一個 <code>DivisionOperator</code> 即可。</p><blockquote><p>需求變更時，我們不再是直接暴力的去修改主程式（<code>calculate_two_float()</code>）中的程式碼，而是透過新增一個 <code>Operator</code> 子類來外接。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operator</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinusOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a - b<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_two_float</span>(<span class="hljs-params">operator: Operator, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    res: <span class="hljs-built_in">float</span> = operator.calculate(a, b)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;result: <span class="hljs-subst">&#123;res&#125;</span>&quot;</span>)<br>    <span class="hljs-keyword">return</span> res<br><br>calculate_two_float(AddOperator(), <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 15</span><br>calculate_two_float(MinusOperator(), <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h2 id="里氏替換原則（Liskov-Substitution-Principle）："><a href="#里氏替換原則（Liskov-Substitution-Principle）：" class="headerlink" title="里氏替換原則（Liskov Substitution Principle）："></a>里氏替換原則（Liskov Substitution Principle）：</h2><p>主要概念就是：<font color=#FF0000><strong>子類必須能夠完全替換父類</strong></font>。<br>也就是說，假設我有一個模組的擴充點為一個類別。當之後要擴展時，我會去繼承這個擴充點類別，並覆寫裡面的方法。而當我將這個「擴充子類別」插入原有模組時，不應該發生異常，並能正確運行。</p><p>而子類如何能夠完全替換父類呢？<br>主要是要做到兩點：「<strong>子類要求的不應該比父類別多</strong>」、「<strong>子類返回的不應該比父類別少</strong>」。</p><ul><li>要求指的是<strong>輸入參數</strong>。假設父類是「矩形」類別，要求兩個參數「長」跟「寬」。我們繼承的子類就不能是方形，因為會多要求長跟寬要一樣，不符合里氏替換原則。</li><li>返回指的是<strong>返回值</strong>。假設父類是「方形」類別，會返回一個長寬等長的矩形。我們繼承的子類就不能隨便返回一個長方形，因為會減少返回的條件，這樣後續程式可能就會出錯。</li></ul><h3 id="簡單範例：-2"><a href="#簡單範例：-2" class="headerlink" title="簡單範例："></a><font color=#d2691e>簡單範例：</font></h3><p>這邊的 <code>BadSon</code> 就是因為沒有達到「<strong>子類返回的不應該比父類別少</strong>」，所以導致程式出錯。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Father</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>:<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;duke&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">18</span><br>        &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GoodSon</span>(<span class="hljs-title class_ inherited__">Father</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>:<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;jamie&quot;</span>,<br>            <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">20</span><br>        &#125;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">BadSon</span>(<span class="hljs-title class_ inherited__">Father</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_info</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">dict</span>:<br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;ken&quot;</span><br>        &#125;<br>    <br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hello</span>(<span class="hljs-params">person: Father</span>) -&gt; <span class="hljs-literal">None</span>:<br>    info: <span class="hljs-built_in">dict</span> = person.get_info()<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hi, I&#x27;m <span class="hljs-subst">&#123;info[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span> and <span class="hljs-subst">&#123;info[<span class="hljs-string">&#x27;age&#x27;</span>]&#125;</span> years old.&quot;</span>)<br><br>say_hello(Father())  <span class="hljs-comment"># Hi, I&#x27;m duke and 18 years old.</span><br>say_hello(GoodSon())  <span class="hljs-comment"># Hi, I&#x27;m jamie and 20 years old.</span><br>say_hello(BadSon())  <span class="hljs-comment"># KeyError: &#x27;age&#x27;</span><br></code></pre></td></tr></table></figure><h2 id="介面隔離原則（Interface-Segregation-Principle）："><a href="#介面隔離原則（Interface-Segregation-Principle）：" class="headerlink" title="介面隔離原則（Interface Segregation Principle）："></a>介面隔離原則（Interface Segregation Principle）：</h2><p>主要概念就是：<font color=#FF0000><strong>實做多個專門的介面比實做一個大而全的介面要好</strong></font>。<br>若一個介面定義太多要求，而我們的子類只需要其中一部份方法時，就只能放棄實做這個介面，或是用空實作和錯誤處理去欺騙介面。這是非常糙的程式碼，因為我們工程師就是透過介面加速理解程式，結果子類根本沒有介面有的方法，這會大大誤導我們。</p><p>若發生上述的事件，就是在提醒我們<strong>介面太過臃種了，要拆分成幾個專門的小介面來實做</strong>。</p><h3 id="簡單範例：-3"><a href="#簡單範例：-3" class="headerlink" title="簡單範例："></a><font color=#d2691e>簡單範例：</font></h3><p>像這個 <code>Bird</code> 介面是真的鳥，如果我們之後有了企鵝要去繼承時，就會發現它無法實現 <code>fly()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><p>所以我們要把 <code>Bird</code> 介面拆成 <code>CanFly</code> 和 <code>CanEat</code> 介面，之後去定義子類時再根據所需繼承即可。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CanFly</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">CanEat</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NormalBird</span>(CanFly, CanEat):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">fly</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I can fly&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I can eat&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Penguin</span>(<span class="hljs-title class_ inherited__">CanEat</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>): <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I can eat&quot;</span>)<br></code></pre></td></tr></table></figure><h2 id="依賴反轉原則（Dependency-Inversion-Principle）："><a href="#依賴反轉原則（Dependency-Inversion-Principle）：" class="headerlink" title="依賴反轉原則（Dependency-Inversion Principle）："></a>依賴反轉原則（Dependency-Inversion Principle）：</h2><p>什麼是依賴？<br>依賴就是一種<strong>受到牽制</strong>的感覺。例如老菸槍沒有煙就會活不下去，代表老菸槍依賴香煙。<br>而程式中也是如此，如果 <strong>Ａ 會直接受到 Ｂ 的影響，就表示 Ａ 依賴了 Ｂ</strong>。例如使用「SQL 查詢」前要先進行「資料庫連線」，所以表示「SQL 查詢」會依賴「資料庫連線」。</p><h4 id="依賴反轉原則的主要概念如下："><a href="#依賴反轉原則的主要概念如下：" class="headerlink" title="依賴反轉原則的主要概念如下："></a><font color=#6495ed>依賴反轉原則的主要概念如下：</font></h4><p>目的是要解除「高階模組 (呼叫者) 」與「低階模組 (被呼叫者)」間的耦合關係，使高階模組<strong>不再直接依賴</strong>低階模組。因為真正需要依賴的，並<strong>不是實際的類別、物件，而是它所擁有的功能</strong>。</p><ol><li><p><strong>高階模組不應該依賴於低階模組。兩者都應該依賴抽象：</strong></p><blockquote><p>原本是 <code>高階模組(SQL 查詢) -&gt; 低階模組(資料庫連線)</code> 的關係，<br>變成了 <code>高階模組(SQL 查詢) -&gt; 介面(提供 get_cursor 方法) &lt;- 低階模組(資料庫連線)</code>。</p></blockquote><p>雖然我們知道「SQL 查詢」會依賴「資料庫連線」。但「SQL 查詢」不應該直接去依賴「資料庫連線」，而是<strong>藉由抽象（例如定義一個介面，裡面有 <code>get_cursor()</code> 的方法）來隔開</strong>。</p></li><li><p><strong>抽象不應該依賴具體實做；具體實做應該依賴抽象：</strong></p><blockquote><p>原本是 <code>高階模組 -(建立)-&gt; 低階模組</code>，<br>變成了 <code>高階模組 &lt;-(傳遞低階模組)- 控制反轉中心</code>。</p></blockquote><p>簡單來說就是我們原本會把<strong>「建立資料庫連線」的具體實做</strong>放在「查詢函數」中，但這樣就表示我們還是在依賴它。所以我們應該將它提出，並通過參數的方式傳進「查詢函數」裡。</p></li></ol><h3 id="簡單範例：-4"><a href="#簡單範例：-4" class="headerlink" title="簡單範例："></a><font color=#d2691e>簡單範例：</font></h3><p>假設我們現在有個計算兩浮點數的函數：</p><blockquote><p>目前因為要用加法，所以我們直接寫死 <code>a+b</code>。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_two_float</span>(<span class="hljs-params">a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    <span class="hljs-keyword">return</span> a + b<br></code></pre></td></tr></table></figure><p>但如果我們之後要換成「減法」，就只能透過修改 <code>calculate_two_float()</code> 函數，將 <code>a+b</code> 改成 <code>a-b</code>。</p><p>所以我們要依照「<strong>高階模組不應該依賴於低階模組。兩者都應該依賴抽象</strong>」準則，創造一個介面來解偶兩者，如下所示： </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operator</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinusOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a - b<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_two_float</span>(<span class="hljs-params">a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    operator: Operator = AddOperator()<br>    <span class="hljs-keyword">return</span> operator.calculate(a, b)<br></code></pre></td></tr></table></figure><p>但這樣還不夠，我們換成減法時還是要去修改 <code>calculate_two_float()</code> 函數，將 <code>AddOperator</code> 改成 <code>MinusOperator</code>，這樣還是違反「開放封閉原則」。</p><blockquote><p>而且這邊有個大問題，就是如果我們都有了介面（<code>Operator</code>），那就不應該直接去實例化 <code>AddOperator</code>，因為這樣介面就沒有存在的意義了。</p></blockquote><p>所以我們還須依照「<strong>抽象不應該依賴具體實做；具體實做應該依賴抽象</strong>」準則，做到「控制反轉」。也就是說，<strong>不能讓具體實做子類的實例化放在模塊中</strong>，如下所示：</p><blockquote><p>讓<strong>介面成為參數的約束</strong>，我們只要保證參數有 <code>calculate()</code> 這個能力即可。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Operator</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AddOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MinusOperator</span>(<span class="hljs-title class_ inherited__">Operator</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate</span>(<span class="hljs-params">self, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>        <span class="hljs-keyword">return</span> a - b<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">calculate_two_float</span>(<span class="hljs-params">operator: Operator, a: <span class="hljs-built_in">float</span>, b: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-built_in">float</span>:<br>    res: <span class="hljs-built_in">float</span> = operator.calculate(a, b)<br>    <span class="hljs-keyword">return</span> res<br><br>calculate_two_float(AddOperator(), <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 15</span><br>calculate_two_float(MinusOperator(), <span class="hljs-number">10</span>, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 5</span><br></code></pre></td></tr></table></figure><h2 id="參考資料："><a href="#參考資料：" class="headerlink" title="參考資料："></a>參考資料：</h2><ul><li><a href="https://wadehuanglearning.blogspot.com/2019/12/blog-post.html">再談物件導向設計原則: 單一職責原則，定義、解析與實踐</a></li><li><a href="https://igouist.github.io/post/2020/09/oo-9-solid/">菜雞與物件導向 (9): SOLID</a></li><li><a href="https://notfalse.net/1/dip">依賴反向原則 (Dependency-Inversion Principle, DIP)</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（四）：抽象類別與介面</title>
    <link href="/2023/08/04/python-oop-abstract-interface/"/>
    <url>/2023/08/04/python-oop-abstract-interface/</url>
    
    <content type="html"><![CDATA[<p>雖然在 Python 中，<strong>沒有介面（Interface）只有抽象類別（Abstract class）</strong>，但我還是來跟大家分享一下這兩者有什麼異同。</p><span id="more"></span><h2 id="先來聊聊為什麼需要抽象類別和介面？"><a href="#先來聊聊為什麼需要抽象類別和介面？" class="headerlink" title="先來聊聊為什麼需要抽象類別和介面？"></a>先來聊聊為什麼需要抽象類別和介面？</h2><blockquote><p>這邊我會先用「抽象」來統一代表「抽象類別」和「介面」兩者。</p></blockquote><p>我們先將「抽象」想像成現實世界中的「證照」。</p><p>假設我們現在是一名面試官，當我們面對上百件的履歷時，要怎麼快速篩選出一批不錯的苗子呢？<br>我們大多會從「是否有專業證照」下手，因為這些「證照」就好像一種標誌，讓我們知道面試者具備這一項技能（<strong>雖然不知道他實際用的好不好</strong>），但至少比沒有證照的面試者值得相信多了。</p><p>而在程式中也是一樣的，工程師可以透過這個類別實做了哪些介面、繼承哪些抽象類別，就能大概判斷出它能做到哪些功能。但這也跟證照例子一樣，我們<strong>不知道他是怎麼實現的、寫的好不好</strong>，但依然能讓工程師理解該類別具備哪些功能。</p><p>因為「抽象」會帶有一定的<strong>強制性</strong>，所以我們可以用它來要求我們的類別必須具備哪些功能。就像是我們當面試官時可以要求面試者一定要有哪張證照才行，因為我們的職缺需要這項技能。</p><h3 id="抽象的優缺點："><a href="#抽象的優缺點：" class="headerlink" title="抽象的優缺點："></a><font color=#d2691e>抽象的優缺點：</font></h3><h4 id="優點："><a href="#優點：" class="headerlink" title="優點："></a><font color=#6495ed>優點：</font></h4><ol><li>可以確保在子類中具備必要方法，也能讓工程師更容易理解子類有什麼功能。</li><li>降低<strong>類別間的耦合</strong>。相較於一連串的繼承（父類 -&gt; 子類 -&gt; 孫子類…），將要實現的功能拆分出多個小介面，子類再依照要具備的功能分別去 implements 它，這樣就不太會跟其他類別有高耦合。</li><li>可搭配「多型」使用，各子類可以<strong>以不同的方式</strong>實現相同的抽象方法，以此達到多型。<blockquote><p>若想了解多型的人，可以參考我的另一篇文章：<a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a>。</p></blockquote></li></ol><h4 id="缺點："><a href="#缺點：" class="headerlink" title="缺點："></a><font color=#6495ed>缺點：</font></h4><ol><li>不能直接實例化出物件，須透過子類實現抽象方法後才能實例化，會<strong>增加程式碼量</strong>。</li><li>如果設計不當，可能會使代碼更難以理解和維護，<strong>增加程式複雜性</strong>。</li><li>當「抽象」需要進行修改時，子類也須做相對應的更改，可能會增加一些開發成本。</li></ol><h2 id="介面（Interface）："><a href="#介面（Interface）：" class="headerlink" title="介面（Interface）："></a>介面（Interface）：</h2><blockquote><p>因為 Python 沒有介面，所以就先用 <font color=#FF0000><strong>Java</strong></font> 來當作範例。</p></blockquote><p>介面就像合約一樣，用來定義子類應該具備的方法。介面僅定義了<strong>方法名、參數和類型，不提供方法的實現</strong>，也可在介面中定義<strong>常數</strong>供子類調用。</p><h3 id="程式範例："><a href="#程式範例：" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>這邊在 Shape 介面中定義了計算面積的方法（<code>show_area()</code>），所以 implements Shape 介面的圖形類別，都必須要去實現 <code>show_area()</code> 的具體內容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">interface</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-keyword">final</span> <span class="hljs-type">double</span> <span class="hljs-variable">PI</span> <span class="hljs-operator">=</span> <span class="hljs-number">3.14</span>;<br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show_area</span><span class="hljs-params">()</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">Shape</span> &#123;<br>   <span class="hljs-type">double</span> radius;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-title function_">Circle</span><span class="hljs-params">(<span class="hljs-type">double</span> r)</span> &#123;<br>       radius=r;<br>   &#125;<br>   <br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">show_area</span><span class="hljs-params">()</span> &#123;<br>       System.out.println(<span class="hljs-string">&quot;area = &quot;</span> + PI * radius * radius);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="抽象類別（Abstract-class）："><a href="#抽象類別（Abstract-class）：" class="headerlink" title="抽象類別（Abstract class）："></a>抽象類別（Abstract class）：</h2><blockquote><p>不過為什麼 Java 要兩種都要用呢，感覺抽象類別比介面靈活很多阿？<br>因為抽象類別是用「繼承」的，但 Java 只能單一繼承；而介面是用「實做」的，一個類別可以實做多重介面。</p></blockquote><p>抽象類別跟介面一樣，可以在其中定義抽象方法（僅定義方法名、參數和類型，不提供方法的實現）和常數。除了上述之外，抽象類別也能包含<strong>具體方法</strong>（有具體實現的方法）和<strong>實例屬性</strong>，其實可以簡單的把抽象類別看做是一種<strong>能定義抽象方法的一般類別</strong>。</p><h3 id="程式範例：-1"><a href="#程式範例：-1" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>因為所有動物都會跑，所以可以直接在抽象類別定義 <code>run()</code> 的具體方法，但因為每個動物的叫聲都不一樣，所以只定義了抽象的 <code>say()</code> 方法來讓子類去實做。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">run</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I&#x27;m running.&quot;</span>)<br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>: <br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;喵喵喵！&quot;</span>)<br><br><br>cat: Cat = Cat()<br>cat.run()  <span class="hljs-comment"># I&#x27;m running.</span><br>cat.say()  <span class="hljs-comment"># 喵喵喵！</span><br></code></pre></td></tr></table></figure><h2 id="抽象類別-vs-介面："><a href="#抽象類別-vs-介面：" class="headerlink" title="抽象類別 vs 介面："></a>抽象類別 vs 介面：</h2><blockquote><p>以下是用 <font color=#FF0000><strong>Java</strong></font> 這種兩者都有的語言來進行比較。</p></blockquote><h3 id="相同點："><a href="#相同點：" class="headerlink" title="相同點："></a><font color=#d2691e>相同點：</font></h3><p>抽象類別與介面兩者都<strong>無法直接實體化</strong>，且其子類<strong>須實現抽象方法</strong>。</p><h3 id="相異點："><a href="#相異點：" class="headerlink" title="相異點："></a><font color=#d2691e>相異點：</font></h3><h4 id="可定義的東西："><a href="#可定義的東西：" class="headerlink" title="可定義的東西："></a><font color=#6495ed>可定義的東西：</font></h4><ul><li>介面：只能定義<strong>抽象方法</strong>（僅定義方法名、參數和類型，不提供方法的實現）與<strong>常數</strong></li><li>抽象類別：除了抽象方法與常數，還可定義<strong>具體方法</strong>和<strong>實例屬性</strong></li></ul><h4 id="繼承方式："><a href="#繼承方式：" class="headerlink" title="繼承方式："></a><font color=#6495ed>繼承方式：</font></h4><blockquote><p>備註：因 Python 是允許多重繼承的，所以可以繼承多個抽象類別，這可能也是 Python 不需要介面的原因。</p></blockquote><ul><li>介面：透過「實做」的方式，一個類別可以<strong>實做多個介面</strong></li><li>抽象類別：透過「繼承」的方式，只能單一繼承</li></ul><h4 id="用途："><a href="#用途：" class="headerlink" title="用途："></a><font color=#6495ed>用途：</font></h4><ul><li>介面：通常是用 <strong>has-a</strong> 的概念，子類依據需要的功能去實做對應的介面</li><li>抽象類別：通常是用 <strong>is-a</strong> 的概念，就像是繼承一般類別一樣，只是還須實現抽象類別的抽象方法</li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（三）：覆寫與多載</title>
    <link href="/2023/08/03/python-oop-override-overload/"/>
    <url>/2023/08/03/python-oop-override-overload/</url>
    
    <content type="html"><![CDATA[<p>覆寫（Override）、多載（Overload）與多型（Polymorphism）一直新手的一大夢魘。就算是工作了幾年的人還是會被這些相像的名詞給搞混，所以本篇章就來聊聊覆寫與多載。<br>若想了解多型的人，可以參考我的另一篇文章：<a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a>。</p><span id="more"></span><h2 id="多載（Overload）："><a href="#多載（Overload）：" class="headerlink" title="多載（Overload）："></a>多載（Overload）：</h2><blockquote><p>先在開頭聲明 <font color=#FF0000><strong>Python 是不能做到像 Java 那樣的 Overload</strong></font> 的。因為如果類中有多個同名方法，Python 只會讀最後一個，其他的會被覆蓋掉。</p></blockquote><p>先來說說在別的語言中的 Overload 是指什麼。<br>在 Java 中，Overload 指的是在一個類別裡，<strong>定義多個名稱相同但參數不同的方法</strong>。之後類別實例呼叫方法時，會根據調用所帶的參數數量和型別，來判定要調用哪個同名方法。</p><h3 id="程式範例："><a href="#程式範例：" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>如果我調用 <code>setCar()</code> 的參數只帶了一個 String 時，它會走第一個方法，並認為這個參數值是車名，其他以此類推。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Car</span>&#123;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(String name)</span>&#123;<br>System.out.printf(<span class="hljs-string">&quot;車名: %s&quot;</span>, name);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(<span class="hljs-type">int</span> dollar)</span>&#123;<br>System.out.printf(<span class="hljs-string">&quot;價錢: %d&quot;</span>, dollar);<br>&#125;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">setCar</span><span class="hljs-params">(String name, <span class="hljs-type">int</span> dollar)</span>&#123;<br>System.out.printf(<span class="hljs-string">&quot;車名: %s 價錢: %d&quot;</span>, name, dollar);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="延伸閱讀：Python-如何做到類似-Overload-的功能？"><a href="#延伸閱讀：Python-如何做到類似-Overload-的功能？" class="headerlink" title="延伸閱讀：Python 如何做到類似 Overload 的功能？"></a><font color=#d2691e>延伸閱讀：Python 如何做到類似 Overload 的功能？</font></h3><blockquote><p>可變參數類型：因為 Python 是動態語言，參數不會預先定義類型。<br>可變參數個數：可利用 <code>Optional Argument</code> 或 <code>*args</code> 或 <code>**kwargs</code> 的機制來達成類似效果。</p></blockquote><p>因為 <strong>Overload 要解決的問題是函數要能接受「可變參數類型」與「可變參數個數」</strong>，而 Python 因本身的機制不會遇到這些問題。 </p><p>這邊用 <code>Optional Argument</code>（默認參數）來舉例，讓 Python 做到類似多載的功能：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Optional</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hello</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span>, age: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>]=<span class="hljs-literal">None</span></span>):<br>        <span class="hljs-keyword">if</span> age <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My name is <span class="hljs-subst">&#123;name&#125;</span>.&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My name is <span class="hljs-subst">&#123;name&#125;</span>, I&#x27;m <span class="hljs-subst">&#123;age&#125;</span> years old.&quot;</span>)<br><br><br>duke: Person = Person()<br>duke.hello(<span class="hljs-string">&quot;duke&quot;</span>)  <span class="hljs-comment"># My name is duke.</span><br>duke.hello(<span class="hljs-string">&quot;duke&quot;</span>, <span class="hljs-number">28</span>)  <span class="hljs-comment"># My name is duke, I&#x27;m 28 years old.</span><br></code></pre></td></tr></table></figure><h2 id="覆寫（Override）："><a href="#覆寫（Override）：" class="headerlink" title="覆寫（Override）："></a>覆寫（Override）：</h2><blockquote><p>通常使用多型（Polymorphism）時，常常會伴隨著覆寫（Override）。<br>若想了解多型的人，可以參考我的另一篇文章：<a href="https://duke851230.github.io/2023/08/02/python-oop-three-principles/">Python 與物件導向（二）：類別的三大特性</a>。</p></blockquote><p>Override 一定是搭配著繼承使用的。指的是<strong>子類可以定義一個與父類方法同名的方法</strong>，當<strong>子類實例</strong>調用該方法時，該方法會覆蓋掉父類方法的內容，讓子類可以擁有不同於父類的行為。</p><blockquote><p>Override 時要注意<strong>參數個數不可變</strong>，若有用 Type Hint 的話，類型也不要變，以免造成之後難以維護！</p></blockquote><h3 id="程式範例：-1"><a href="#程式範例：-1" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>我們的 Dog 與 Cat 類別都覆寫了 Animal 的 <code>say()</code> 方法。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;喵喵喵！&quot;</span>)<br><br>Dog().say()  <span class="hljs-comment"># 汪汪汪！</span><br>Cat().say()  <span class="hljs-comment"># 喵喵喵！</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（二）：類別的三大特性</title>
    <link href="/2023/08/02/python-oop-three-principles/"/>
    <url>/2023/08/02/python-oop-three-principles/</url>
    
    <content type="html"><![CDATA[<p>接下來要講講熟悉物件導向設計的工程師都不陌生的三大特性——封裝、繼承與多型。如果不熟悉類別與物件的朋友們，可以參考我的上一篇文章：<a href="https://duke851230.github.io/2023/08/01/python-oop-object/">Python 與物件導向（一）：類別與物件</a>。</p><span id="more"></span><h2 id="為什麼需要學習這個酷東西呢？"><a href="#為什麼需要學習這個酷東西呢？" class="headerlink" title="為什麼需要學習這個酷東西呢？"></a>為什麼需要學習這個酷東西呢？</h2><blockquote><p>你可能會有疑問，為什麼每次在提到物件導向設計時，總是會伴隨著「封裝」、「繼承」、「多型」這幾個詞彙？</p></blockquote><p>這是因為好好善用這幾個原則的話，可以讓我們的程式碼更加模組化且易於維護。</p><h2 id="封裝（Encapsulation）："><a href="#封裝（Encapsulation）：" class="headerlink" title="封裝（Encapsulation）："></a>封裝（Encapsulation）：</h2><p>封裝主要是為了做到兩件事：</p><ol><li>控制與外部進行互動的出入口，對外部僅<strong>提供有限的接口</strong>來訪問。</li><li>隱藏內部的實現細節</li></ol><blockquote><p>如果以電視遙控器來舉例的話，當我們按了開機鍵，我們<strong>不需要知道它背後是以什麼原理運作的</strong>，我們只要知道當我們按下它後，電視就會被打開。</p></blockquote><p>在程式設計中也是如此，外部使用者不需考慮我們類別內部的實作細節，就可以直接呼叫使用。且因為只提供「有限的接口」給外部使用，也可以避免物件被不正確的使用和修改，提高程式碼的穩定性。</p><h3 id="程式範例："><a href="#程式範例：" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>這邊有一個 Person 類別，我們有開放 height 的讀寫接口和 birthday 的讀接口，因為<strong>出生日是固定的不能被修改</strong>。</p><blockquote><p>我們可以簡單理解 <code>__&#123;variable&#125;</code> 為私有屬性（不能直接被外部讀寫）。但我們在之後有使用 <code>@property</code> 裝飾器，來提供一個名為 birthday 的<strong>唯讀接口</strong>。  </p></blockquote><blockquote><p><code>@property</code> 裝飾器簡單來說就是，讓被裝飾的方法可以像調用屬性那樣被調用。（在此範例就是可以用 <code>&#123;object&#125;.birthday</code> 來調用 <code>birthday()</code> 方法）</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datetime <span class="hljs-keyword">import</span> date<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, birthday: date, height: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.__birthday: date = birthday<br>        self.height: <span class="hljs-built_in">int</span> = height<br><br><span class="hljs-meta">    @property</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">birthday</span>(<span class="hljs-params">self</span>) -&gt; date:<br>        <span class="hljs-keyword">return</span> self.__birthday<br></code></pre></td></tr></table></figure><p>從下面的範例程式我們可以看到：</p><ul><li><code>height</code> 因為沒有加以限制，所以可以直接被外部讀寫。</li><li><code>__birthday</code> 因為被定義成私有屬性，所以不能被外部讀寫。但我們有額外提供 <code>birthday</code> 接口供外部讀取 <code>__birthday</code> 屬性（沒有提供寫的權力）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">duke: Person = Person(birthday=date(<span class="hljs-number">1996</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), height=<span class="hljs-number">179</span>)<br><span class="hljs-built_in">print</span>(duke.height)  <span class="hljs-comment"># 179</span><br>duke.height = <span class="hljs-number">180</span>   <span class="hljs-comment"># 不會 Error，因為有公開 height 屬性給外部修改</span><br><span class="hljs-built_in">print</span>(duke.height)  <span class="hljs-comment"># 180</span><br><br><span class="hljs-comment"># print(duke.__birthday)  # AttributeError: &#x27;Person&#x27; object has no attribute &#x27;__birthday&#x27;，因為是私有屬性外部讀不到</span><br><br><span class="hljs-built_in">print</span>(duke.birthday)  <span class="hljs-comment"># 1996-01-01</span><br>duke.birthday = date(<span class="hljs-number">2000</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment"># AttributeError: can&#x27;t set attribute，因為沒有開放給別人修改出生日的權力</span><br></code></pre></td></tr></table></figure><h3 id="延神閱讀："><a href="#延神閱讀：" class="headerlink" title="延神閱讀："></a><font color=#d2691e>延神閱讀：</font></h3><p>其實 Python 本身是沒有像 Java 那樣提供真正的私有屬性，所以我們真的硬要讀寫 <code>__&#123;variable&#125;</code> 是做得到的，只是通常沒人會這樣做。</p><p>只要透過 <code>_&#123;class&#125;__&#123;variable&#125;</code> 就可以強制讀寫「<strong>俗成上</strong>的私有屬性」。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">duke: Person = Person(birthday=date(<span class="hljs-number">1996</span>, <span class="hljs-number">1</span>, <span class="hljs-number">1</span>), height=<span class="hljs-number">179</span>)<br><span class="hljs-built_in">print</span>(duke._Person__birthday)  <span class="hljs-comment"># 1996-01-01</span><br></code></pre></td></tr></table></figure><h2 id="繼承（Inheritance）："><a href="#繼承（Inheritance）：" class="headerlink" title="繼承（Inheritance）："></a>繼承（Inheritance）：</h2><blockquote><p><strong>繼承是一種「is-a」的關係</strong>，當你能說出Ａ是一個Ｂ的時候，就代表你認為Ａ可以繼承自Ｂ。</p></blockquote><p>使用繼承，可以讓「子類」獲取「父類」的屬性和方法，並且在此基礎上擴展自己的屬性和方法。這樣可以節省重複性的程式碼，使程式碼更加簡潔。</p><p>但正是因為繼承很方便，所以容易遭到濫用，導致程式碼變得複雜且難以維護，不過這留到之後的篇章再來跟大家聊聊。</p><h3 id="程式範例：-1"><a href="#程式範例：-1" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>這邊提供了一個最簡單的範例，來告訴大家子類可以繼承父類的所有屬性和方法（不包括 <code>__&#123;variable&#125;</code>）。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name</span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.name = name<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is eating.&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">bark</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.name&#125;</span> is barking.&quot;</span>)<br><br><br>dog: Dog = Dog(<span class="hljs-string">&quot;Buddy&quot;</span>)<br>dog.eat()  <span class="hljs-comment"># 繼承了 Animal 類別的 eat() 方法</span><br>dog.bark() <span class="hljs-comment"># Dog 類別自定義的 bark() 方法</span><br></code></pre></td></tr></table></figure><h3 id="延神閱讀：那私有屬性和方法會被繼承嗎？"><a href="#延神閱讀：那私有屬性和方法會被繼承嗎？" class="headerlink" title="延神閱讀：那私有屬性和方法會被繼承嗎？"></a><font color=#d2691e>延神閱讀：那私有屬性和方法會被繼承嗎？</font></h3><p>答案是「不會被繼承」。</p><p>透過以下範例看得出來，我們無法在 Asian 類中直接透過 <code>self.__race</code> 拿到 Person 類的私有屬性。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.__race: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;人族&quot;</span><br>        self.name = name<br><br><span class="hljs-comment"># 黃種人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Asian</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My name is <span class="hljs-subst">&#123;self.name&#125;</span>.&quot;</span>)<br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_race</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My race is <span class="hljs-subst">&#123;self.__race&#125;</span>.&quot;</span>)<br>    <br><br>duke: Asian = Asian(<span class="hljs-string">&quot;duke&quot;</span>)<br>duke.get_name()  <span class="hljs-comment"># My name is duke.</span><br>duke.get_race()  <span class="hljs-comment"># AttributeError: &#x27;Asian&#x27; object has no attribute &#x27;_Asian__race&#x27;，因為透過 self 去找 __variable 時會自動帶上類名去找</span><br></code></pre></td></tr></table></figure><p>但簡單做個小更改就可以讓 Asian 的實例去讀取 race 屬性：<br>我們將 <code>get_race()</code> 移至 Person 類，這樣 <code>self.__race</code> 就能訪問到屬於 Person 本身的私有屬性了。而且因為 <code>get_race()</code> 不是私有方法，所以可被 Asian 類繼承。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.__race: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;人族&quot;</span><br>        self.name = name<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_race</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My race is <span class="hljs-subst">&#123;self.__race&#125;</span>.&quot;</span>)<br><br><span class="hljs-comment"># 黃種人</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Asian</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_name</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;My name is <span class="hljs-subst">&#123;self.name&#125;</span>.&quot;</span>)<br><br>duke: Asian = Asian(<span class="hljs-string">&quot;duke&quot;</span>)<br>duke.get_name()  <span class="hljs-comment"># My name is duke.</span><br>duke.get_race()  <span class="hljs-comment"># My race is 人族.</span><br></code></pre></td></tr></table></figure><h2 id="多型（Polymorphism）："><a href="#多型（Polymorphism）：" class="headerlink" title="多型（Polymorphism）："></a>多型（Polymorphism）：</h2><blockquote><p>簡單的說，就是<strong>不同人做一樣的事，會有不同的做法</strong>。</p></blockquote><p>通常會跟繼承一起使用，多型是指同一方法可以<strong>根據不同的物件類型而有不同的實現方式</strong>，這樣可以讓程式更加靈活。</p><h3 id="程式範例：-2"><a href="#程式範例：-2" class="headerlink" title="程式範例："></a><font color=#d2691e>程式範例：</font></h3><p>我們知道貓和狗的叫聲是不一樣的，所以 <code>Dog</code> 和 <code>Cat</code> 類分別實作了 <code>say()</code> 方法來模擬叫聲。<br>之後我們根據不同實例（來自於實現 <code>Dog</code> 和 <code>Cat</code> 類）來呼叫 <code>say()</code> 方法，就會發現叫聲會隨著實例的類別不同而改變，這就是「多型」。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> abc <span class="hljs-keyword">import</span> ABC, abstractmethod<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>(<span class="hljs-title class_ inherited__">ABC</span>):<br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;汪汪汪！&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;喵喵喵！&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_sound</span>(<span class="hljs-params">animal: Animal</span>) -&gt; <span class="hljs-literal">None</span>:<br>    animal.say()<br><br><br>make_sound(Dog())  <span class="hljs-comment"># 汪汪汪！，Dog 物件呼叫自己的 say() 方法</span><br>make_sound(Cat())  <span class="hljs-comment"># 喵喵喵！，Cat 物件呼叫自己的 say() 方法</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Python 與物件導向（一）：類別與物件</title>
    <link href="/2023/08/01/python-oop-object/"/>
    <url>/2023/08/01/python-oop-object/</url>
    
    <content type="html"><![CDATA[<p>工作也有些年頭了，趁這個機會來總結一下之前所學的知識，若有不足之處，請多多包含。第一篇就來分享一下何謂類別（Class）與物件（Object）。</p><span id="more"></span><h2 id="什麼是物件（Object）？"><a href="#什麼是物件（Object）？" class="headerlink" title="什麼是物件（Object）？"></a>什麼是物件（Object）？</h2><p>如果以現實世界來形容的話，物件就充斥在我們身邊，我們所能看到的一切都是物件。不管是車子、房子、人、貓、狗等等，只要是你能說的出來的「東西」都是物件。</p><p>而在 Python 等物件導向語言中，也是將所有東西視為物件。不管是 class、function、int、float、string 等等，<font color=#FF0000><strong>在 Python 中一切皆視為「物件」</strong></font>。</p><blockquote><p>你沒看錯，class 在 Python 中也被視為物件。<br>這會涉及到比較深的知識點，我之後再找時間分享，大家有興趣的話可以先上網搜尋<strong>元類（Metaclass）</strong>和 <strong>type</strong>。</p></blockquote><h2 id="什麼是類別（Class）？"><a href="#什麼是類別（Class）？" class="headerlink" title="什麼是類別（Class）？"></a>什麼是類別（Class）？</h2><blockquote><p>由上述我們可以知道了現實世界中所有東西都是物件，而物件就是用來代表「<strong>某個特定的東西</strong>」。</p></blockquote><p>假設現在有一個叫做「小新」的五歲小朋友，他就是一個物件，而他最愛吃的小熊餅乾也是一個物件。  </p><p>而我們發現物件間是可以<strong>互動</strong>的。像是小新可以吃小熊餅乾，是因為小新身為「人」，所以有「吃東西」這個<font color=#FF0000><strong>行為</strong></font>。<br>同時我們也發現物件是有自己的<font color=#FF0000><strong>特徵</strong></font>的，像是小新身高 100 公分且今年五歲。</p><h3 id="定義類別："><a href="#定義類別：" class="headerlink" title="定義類別："></a><font color=#d2691e>定義類別：</font></h3><p>由上述我們知道小新身為人可以有許多「<strong>行為</strong>」和「<strong>特徵</strong>」，但我們在程式中要怎麼去表達或定義呢？<br>這時我們就會需要使用到類別，類別是用來幫我們定義「同一類的物件」會有哪些行為與特徵。</p><p>像是這邊我們定義了一個「人」的類別，每個人都有「吃東西」這個行為，且有「年齡」和「身高」兩個特徵。</p><blockquote><p>行為在程式中稱為「方法」；特徵在程式中稱為「屬性」。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, age: <span class="hljs-built_in">int</span>, height: <span class="hljs-built_in">float</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        self.age: <span class="hljs-built_in">int</span> = age<br>        self.height: <span class="hljs-built_in">float</span> = height<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">eat</span>(<span class="hljs-params">self, food: <span class="hljs-built_in">str</span></span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;吃<span class="hljs-subst">&#123;food&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>接著就可以用「人」這個類別來表達小新了。</p><blockquote><p>在程式中，會把類別產生的物件叫做「實例」，而從類別產生物件的過程，就叫做<strong>實例化</strong>。</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pytohn"># shinchan 是小新的英文名<br>shinchan: Person = Person(age=5, height=100)<br>shinchan.eat(&quot;小熊餅乾&quot;)<br></code></pre></td></tr></table></figure><p>當然除了小新，我們也能用 Person 類別實例化出風間、正男、阿呆，他們都有自己的年齡身高，且都有吃東西這個行為。</p><h3 id="查看屬性："><a href="#查看屬性：" class="headerlink" title="查看屬性："></a><font color=#d2691e>查看屬性：</font></h3><blockquote><p>在 Python 中，我們可以透過 <code>dir()</code> 和 <code>__dict__</code> 來查看物件的屬性和方法。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">dir</span>(Person)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">本身只有 __init__ 與 eat 方法，其餘皆繼承自父類。</span><br><span class="hljs-string">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;eat&#x27;]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-built_in">dir</span>(shinchan)<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">相較於 Person 類多了 age 與 height 屬性，因為屬性是在實例化後才被賦予的。</span><br><span class="hljs-string">[&#x27;__class__&#x27;, &#x27;__delattr__&#x27;, &#x27;__dict__&#x27;, &#x27;__dir__&#x27;, &#x27;__doc__&#x27;, &#x27;__eq__&#x27;, &#x27;__format__&#x27;, &#x27;__ge__&#x27;, &#x27;__getattribute__&#x27;, &#x27;__getstate__&#x27;, &#x27;__gt__&#x27;, &#x27;__hash__&#x27;, &#x27;__init__&#x27;, &#x27;__init_subclass__&#x27;, &#x27;__le__&#x27;, &#x27;__lt__&#x27;, &#x27;__module__&#x27;, &#x27;__ne__&#x27;, &#x27;__new__&#x27;, &#x27;__reduce__&#x27;, &#x27;__reduce_ex__&#x27;, &#x27;__repr__&#x27;, &#x27;__setattr__&#x27;, &#x27;__sizeof__&#x27;, &#x27;__str__&#x27;, &#x27;__subclasshook__&#x27;, &#x27;__weakref__&#x27;, &#x27;age&#x27;, &#x27;eat&#x27;, &#x27;height&#x27;]</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>Person.__dict__<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;&#x27;__module__&#x27;: &#x27;__main__&#x27;, &#x27;__init__&#x27;: &lt;function Person.__init__ at 0x7fe6f5adde50&gt;, &#x27;eat&#x27;: &lt;function Person.eat at 0x7fe6f5addee0&gt;, &#x27;__dict__&#x27;: &lt;attribute &#x27;__dict__&#x27; of &#x27;Person&#x27; objects&gt;, &#x27;__weakref__&#x27;: &lt;attribute &#x27;__weakref__&#x27; of &#x27;Person&#x27; objects&gt;, &#x27;__doc__&#x27;: None&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>shinchan.__dict__<br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&#123;&#x27;age&#x27;: 5, &#x27;height&#x27;: 100&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="dir-和-dict-差異："><a href="#dir-和-dict-差異：" class="headerlink" title="dir() 和 __dict__ 差異："></a><font color=#6495ed><code>dir()</code> 和 <code>__dict__</code> 差異：</font></h4><blockquote><p><strong><code>__dict__</code> 是 <code>dir()</code> 的子集</strong>，<code>dir()</code> 包含 <code>__dict__</code> 中的屬性！</p></blockquote><p><code>dir()</code> 返回的會是一個 List，裡面為物件的所有屬性和方法名（包括從父類繼承來的）。<br><code>__dict__</code> 返回的是一個 Dict，裡面會包含屬性名和對應的值（不過僅會有該實例本身的屬性）。</p><h2 id="總結："><a href="#總結：" class="headerlink" title="總結："></a>總結：</h2><p>今天這篇文章跟大家粗淺的介紹了物件和類別是什麼，這邊再跟大家做最後的總結。</p><p>類別可以想像成一張<strong>設計圖</strong>，裡面描述了各種行為特徵。而物件則是類別所產生的<strong>特定實體</strong>。<br>例如：「人」這個類別是用來描述什麼是人，能做到什麼，有什麼屬性。而小新這個物件則是透過「人」類別建立的特定的人，有自己的年齡身高屬性，也有吃東西這個行為。</p><h2 id="參考資料："><a href="#參考資料：" class="headerlink" title="參考資料："></a>參考資料：</h2><ul><li><a href="https://www.maxlist.xyz/2021/01/11/python-object/#google_vignette">Python 基礎教學：一切皆為物件，到底什麼是物件 Object ?</a></li><li><a href="https://igouist.github.io/post/2020/07/oo-1-class-object/">菜雞與物件導向 (1)：類別、物件</a></li></ul>]]></content>
    
    
    <categories>
      
      <category>Programming</category>
      
      <category>Python</category>
      
    </categories>
    
    
    <tags>
      
      <tag>OOP</tag>
      
      <tag>Python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（六）- SQL Injection</title>
    <link href="/2023/07/06/SQL_Injection/"/>
    <url>/2023/07/06/SQL_Injection/</url>
    
    <content type="html"><![CDATA[<p>接下來和大家分享同樣位居 OWASP 網頁安全漏洞的前十名的 SQL Injection（SQL 注入）。雖然防範的方式很簡單，但還是有很多新手會不小心忽略了它，所以在此跟大家分享一下它是什麼與如何防護。</p><span id="more"></span><h2 id="先來講講什麼是-SQL-Injection？"><a href="#先來講講什麼是-SQL-Injection？" class="headerlink" title="先來講講什麼是 SQL Injection？"></a>先來講講什麼是 SQL Injection？</h2><h3 id="SQL-Injection-簡介："><a href="#SQL-Injection-簡介：" class="headerlink" title="SQL Injection 簡介："></a><font color=#d2691e>SQL Injection 簡介：</font></h3><blockquote><p>SQL Injection 中文為 SQL 注入式攻擊。</p></blockquote><p>通常發生在應用程序<strong>未對使用者的輸入做驗證</strong>的情況下。駭客通過在輸入字段中插入惡意 SQL 語句，讓資料庫誤以為該指令是合法操作而執行，資料庫就因此遭到入侵。</p><h3 id="SQL-Injection-的攻擊原理："><a href="#SQL-Injection-的攻擊原理：" class="headerlink" title="SQL Injection 的攻擊原理："></a><font color=#d2691e>SQL Injection 的攻擊原理：</font></h3><blockquote><p>SQL 是後端用來與資料庫溝通的程式語言。</p></blockquote><p>SQL Injection 是駭客透過在原 SQL 語句中插入惡意代碼，進而<strong>改變原語句的語意</strong>並達到入侵之目的。通常駭客是利用 SQL 的以下特性來竄改語意：</p><ol><li><p><font color=#6495ed><strong>註解：</strong></font></p><p>駭客可利用註解（<code>-- &#123;annotation&#125;</code> 或 <code>/* &#123;annotation&#125; */</code>）來取消原語句的行為，並插入惡意語句來完成攻擊。<br>以下範例是駭客透過註解繞過密碼驗證：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 後端資安漏洞：</span><br><span class="hljs-comment"># user 與 pwd 是使用者的輸入</span><br>sql = <span class="hljs-string">&quot;SELECT * FROM users WHERE username=&#x27;&#123;user&#125;&#x27; AND password=&#x27;&#123;pwd&#125;&#x27;;&quot;</span>.<span class="hljs-built_in">format</span>(user=user, pwd=pwd)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">正常情況： user = &quot;admin&quot;, pwd = &quot;admin123&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> (username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span>) <span class="hljs-keyword">AND</span> (password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin123&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">駭客攻擊： user = &quot;admin&#x27;; --&quot;, pwd = &quot;&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span>; <span class="hljs-comment">--&#x27; AND password=&#x27;&#x27;;</span><br></code></pre></td></tr></table></figure></li><li><p><font color=#6495ed><strong>單引號：</strong></font></p><blockquote><p>在 SQL 語句中，可使用兩個單引號來表示字串（例如：<code>name = &#39;Duke&#39;</code>）。</p></blockquote><p>駭客利用單引號來結束原本語意，然後插入惡意語句來完成攻擊。以下範例是駭客透過單引號繞過密碼驗證：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 後端資安漏洞：</span><br><span class="hljs-comment"># pwd 為使用者輸入的密碼</span><br>sql = <span class="hljs-string">&quot;SELECT * FROM users WHERE (username=&#x27;admin&#x27;) AND (password=&#x27;&#123;pwd&#125;&#x27;);&quot;</span>.<span class="hljs-built_in">format</span>(pwd=pwd)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">正常情況： pwd = &quot;admin123&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> (username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span>) <span class="hljs-keyword">AND</span> (password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin123&#x27;</span>);<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">駭客攻擊： pwd = &quot;&#x27; OR 1=1&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> (username<span class="hljs-operator">=</span><span class="hljs-string">&#x27;admin&#x27;</span>) <span class="hljs-keyword">AND</span> (password<span class="hljs-operator">=</span><span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-keyword">OR</span> <span class="hljs-number">1</span><span class="hljs-operator">=</span><span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure></li><li><p><font color=#6495ed><strong>分號：</strong></font></p><blockquote><p>在 SQL 語句中，可使用分號來分隔兩個語句。</p></blockquote><p> 駭客利用分號來分隔語句，在分號之後插入惡意語句來完成攻擊。以下範例是駭客透過分號來刪掉資料表：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 後端資安漏洞：</span><br><span class="hljs-comment"># user_id 為使用者輸入的密碼</span><br>sql = <span class="hljs-string">&quot;SELECT * FROM users WHERE id=&#123;user_id&#125;;&quot;</span>.<span class="hljs-built_in">format</span>(user_id=user_id)<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">正常情況： user_id = 1</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>;<br></code></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sql"><span class="hljs-comment">/*</span><br><span class="hljs-comment">駭客攻擊： user_id = &quot;1; DROP table users&quot;</span><br><span class="hljs-comment">*/</span><br><span class="hljs-keyword">SELECT</span> <span class="hljs-operator">*</span> <span class="hljs-keyword">FROM</span> users <span class="hljs-keyword">WHERE</span> id<span class="hljs-operator">=</span><span class="hljs-number">1</span>; <span class="hljs-keyword">DROP</span> <span class="hljs-keyword">TABLE</span> users;<br></code></pre></td></tr></table></figure></li></ol><h2 id="如何防範-SQL-Injection？"><a href="#如何防範-SQL-Injection？" class="headerlink" title="如何防範 SQL Injection？"></a>如何防範 SQL Injection？</h2><h3 id="造成攻擊的原因："><a href="#造成攻擊的原因：" class="headerlink" title="造成攻擊的原因："></a><font color=#d2691e>造成攻擊的原因：</font></h3><p>這邊先來跟大家說說什麼樣的後端設計，會容易導致產生漏洞而被攻擊。</p><ol><li><p>太過信任使用者的輸入，而未對其做任何檢查<br>這是造成 SQL Injection 的主要原因，因為駭客都是透過在輸入中埋惡意腳本的。</p></li><li><p>後端使用不安全的方式（例如：<strong>字符串拼接</strong>）構建 SQL 語句<br>這也是<strong>造成攻擊的主要原因</strong>，因為駭客可以輕易的在其中埋下惡意代碼。</p></li><li><p>資料庫使用者擁有過高的權限，導致災害嚴重<br>通常不應該讓網站的資料庫使用者有刪除資料庫(表)的權力。</p></li></ol><h3 id="防範措施："><a href="#防範措施：" class="headerlink" title="防範措施："></a><font color=#d2691e>防範措施：</font></h3><ol><li><p><font color=#6495ed><strong>參數化查詢（Parameterized Query）：</strong></font></p><blockquote><p>這是<font color=#FF0000><strong>最有效</strong></font>的防範措施。因為在使用參數化查詢的情況下，資料庫<strong>不會將參數內容視為指令的一部份</strong>。</p></blockquote><p>資料庫會先完成 SQL 指令的編譯後，才套用參數運行。因此就算參數中含有惡意指令，但由於未被編譯，所以就不會被資料庫所運行。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># name 與 pwd 是使用者的輸入</span><br>sql = <span class="hljs-string">&quot;SELECT * FROM users WHERE username=? AND password=?;&quot;</span><br>cursor.execute(sql, (name, pwd))<br></code></pre></td></tr></table></figure></li><li><p><font color=#6495ed><strong>ORM（對象關係映射）：</strong></font><br>讓我們以對象的方式操作資料庫，並自動使用<strong>參數化查詢</strong>。</p></li><li><p><font color=#6495ed><strong>參數檢查：</strong></font><br>在使用輸入數據之前，進行嚴格的驗證和過濾。確保數據符合預期的格式，並且過濾掉危險字符。</p></li><li><p><font color=#6495ed><strong>最小權限原則：</strong></font><br>為資料庫用戶分配最小必要權限，這可以減輕危害發生時造成的損害。</p></li><li><p><font color=#6495ed><strong>設置 WAF：</strong></font></p><blockquote><p>WAF 全稱為 Web Application Firewall，使 Web 應用免於遭受惡意攻擊和不必要的流量。</p></blockquote><p>WAF 通常可以檢測多種網絡攻擊，包括 SQL注入、XSS 攻擊、CSRF 攻擊、爬蟲攻擊等。</p></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（五）- CSP</title>
    <link href="/2023/07/05/CSP/"/>
    <url>/2023/07/05/CSP/</url>
    
    <content type="html"><![CDATA[<p>在上一篇文章（<a href="https://duke851230.github.io/2023/07/04/XSS/">Web 資安系列（四）- XSS</a>）中，有提到 CSP 可以用來防禦 XSS 攻擊，所以接下來我就來跟大家分享什麼是 CSP（內容安全策略）。</p><span id="more"></span><h2 id="先來講講什麼是-CSP？"><a href="#先來講講什麼是-CSP？" class="headerlink" title="先來講講什麼是 CSP？"></a>先來講講什麼是 CSP？</h2><h3 id="CSP-簡介："><a href="#CSP-簡介：" class="headerlink" title="CSP 簡介："></a><font color=#d2691e>CSP 簡介：</font></h3><blockquote><p>全名為 Content Security Policy，內容安全策略。</p></blockquote><p>CSP 是一種<strong>網頁安全機制</strong>。用白話來說，就是它能告訴瀏覽器說此網站的哪些位置可以連、哪些位置不能連、允許哪些行為、不允許哪些行為等，可以用來防止惡意腳本在我們的網頁中執行。</p><blockquote><p>會被 XSS 攻擊是因為瀏覽器區分不了哪些是自己的安全腳本、哪些是第三方注入的惡意腳本。</p></blockquote><p>對網頁來說，XSS 是最常見的攻擊手法，駭客會透過漏洞在網站中安插惡意腳本。此時 CSP 就派上用場了，它可以<strong>告知瀏覽器此來源是否受到信任</strong>，來決定是否要執行，以加強網站的安全性。</p><h2 id="CSP-如何使用？"><a href="#CSP-如何使用？" class="headerlink" title="CSP 如何使用？"></a>CSP 如何使用？</h2><blockquote><p>資源可能是 JavaScript、CSS、字體、圖像、影片或任何嵌入的內容。</p></blockquote><p>CSP 通常是透過在<strong>響應頭（Response Header）</strong>中添加規則，以限制瀏覽器載入和執行特定來源的資源。它會告訴瀏覽器只能載入特定來源的資源，阻止載入未受信任的資源，同時也可限制內嵌腳本的執行，以防止 XSS 攻擊。</p><h3 id="CSP-的做法："><a href="#CSP-的做法：" class="headerlink" title="CSP 的做法："></a><font color=#d2691e>CSP 的做法：</font></h3><blockquote><p>目前大部分的瀏覽器都有支援 CSP。</p></blockquote><p>簡單來說，CSP 能向瀏覽器提供<strong>設定白名單</strong>的機制，告訴瀏覽器網頁的哪些位置可以連、允許哪些行為。</p><h3 id="設定-CSP："><a href="#設定-CSP：" class="headerlink" title="設定 CSP："></a><font color=#d2691e>設定 CSP：</font></h3><p>CSP 是由一系列的<strong>指令</strong>和<strong>資料源</strong>所組成，每個指令可以指定多個資料源，並限制相應的資源載入。</p><h4 id="後端響應設定方式："><a href="#後端響應設定方式：" class="headerlink" title="後端響應設定方式："></a><font color=#6495ed>後端響應設定方式：</font></h4><blockquote><p>前端其實也能在 HTML 中設置（但較不推薦）：<br><code>&lt;meta http-equiv=&quot;Content-Security-Policy&quot; content=&quot;&#123;Policy&#125;&quot;&gt;</code><br><code>&lt;meta http-equiv=&quot;Content-Security-Policy-Report-Only&quot; content=&quot;&#123;Policy&#125;&quot;&gt;</code></p></blockquote><ol><li><p>在響應頭中加入 <code>Content-Security-Policy: &#123;Policy&#125;</code><br>當有不符合安全政策的情況時，瀏覽器就會自動提報錯誤，並<strong>終止該行為之執行</strong>。</p></li><li><p>在響應頭中加入 <code>Content-Security-Policy-Report-Only: &#123;Policy&#125;</code><br>當有不符合安全政策的情況時，瀏覽器就會自動提報錯誤，但會繼續執行該行為（<strong>不會終止</strong>）。</p></li></ol><h4 id="設定範例："><a href="#設定範例：" class="headerlink" title="設定範例："></a><font color=#6495ed>設定範例：</font></h4><ol><li><p><code>Content-Security-Policy: default-src &#39;self&#39;;</code>：<br>限制所有的外部資源只能從當前域名加載，也就是指只能從同源處拿資源的意思。</p></li><li><p><code>Content-Security-Policy: default-src &#39;self&#39; http://*.duke.tw;</code>：<br>除了同源資源外，也能信任 <code>http://*.duke.tw</code> 的資源。</p></li><li><p><code>Content-Security-Policy: default-src &#39;self&#39;; style-src http://*.duke.tw;</code>：<br>除了 JavaScript 只能信任 <code>http://*.duke.tw</code> 外，其他資源只能信任同源的。</p></li></ol><h4 id="常用指令："><a href="#常用指令：" class="headerlink" title="常用指令："></a><font color=#6495ed>常用指令：</font></h4><table><thead><tr><th align="center">指令</th><th align="left">指令說明</th></tr></thead><tbody><tr><td align="center"><code>default-src</code></td><td align="left">默認加載策略</td></tr><tr><td align="center"><code>script-src</code></td><td align="left">對 JavaScript 的加載策略</td></tr><tr><td align="center"><code>style-src</code></td><td align="left">對 CSS 的加載策略</td></tr><tr><td align="center"><code>img-src</code></td><td align="left">對圖片的加載策略</td></tr><tr><td align="center"><code>connect-src</code></td><td align="left">對 Ajax、WebSocket 等請求的加載策略</td></tr><tr><td align="center"><code>frame-src</code></td><td align="left">對 fram、iframe 的加載策略</td></tr><tr><td align="center"><code>media-src</code></td><td align="left">對多媒體的加載策略，如：<code>&lt;audio&gt;</code>、<code>&lt;video&gt;</code> 等</td></tr><tr><td align="center"><code>object-src</code></td><td align="left">對非影音的加載策略，如：<code>&lt;object&gt;</code>、<code>&lt;embed&gt;</code> 及 <code>&lt;applet&gt;</code> 等</td></tr></tbody></table><h4 id="常用資料源："><a href="#常用資料源：" class="headerlink" title="常用資料源："></a><font color=#6495ed>常用資料源：</font></h4><table><thead><tr><th align="center">資料源</th><th align="left">資料源說明</th></tr></thead><tbody><tr><td align="center"><code>*</code></td><td align="left">允許任何內容</td></tr><tr><td align="center"><code>&#39;none&#39;</code></td><td align="left">不允許任何內容</td></tr><tr><td align="center"><code>&#39;self&#39;</code></td><td align="left">只允許同源內容</td></tr><tr><td align="center"><code>&#39;unsafe-inline&#39;</code></td><td align="left">允許加載 inline 資源，如：<code>onclick</code>、inline javascript（內聯腳本）</td></tr><tr><td align="center"><code>&#39;unsafe-eval&#39;</code></td><td align="left">允許動態加載程式碼，如：<code>eval()</code></td></tr><tr><td align="center">網址</td><td align="left">允許特定來源內容，如：<code>http://*.duke.tw</code></td></tr></tbody></table><h4 id="script-src-的特殊資料源："><a href="#script-src-的特殊資料源：" class="headerlink" title="script-src 的特殊資料源："></a><font color=#6495ed><code>script-src</code> 的特殊資料源：</font></h4><blockquote><p><code>nonce</code>：設定一個授權 Token，網頁內的內聯腳本必須帶有這個 Token 才能執行。</p></blockquote><p>假設後端的響應帶上了這個：<code>Content-Security-Policy: script-src &#39;nonce-EDNnf03nceIOfn39fn3e9h3sdfa&#39;</code>。</p><blockquote><p>只有 Token 匹配的上才會被執行。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">nonce</span>=<span class="hljs-string">&quot;EDNnf03nceIOfn39fn3e9h3sdfa&quot;</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// inline code</span></span><br><span class="language-javascript">  </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="那要怎麼加入-CSP-響應頭呢？"><a href="#那要怎麼加入-CSP-響應頭呢？" class="headerlink" title="那要怎麼加入 CSP 響應頭呢？"></a>那要怎麼加入 CSP 響應頭呢？</h2><p>這我一開始接觸時也常常搞混，以為 CSP Headers 是加在 Web Application（如 Django）中。但後來想想其實不太可能是加在這，因為主要會被攻擊的是那些靜態檔（如 HTML 文件），而靜態檔通常都是給 Web Server（如 Nginx）管理，所以 <strong>CSP Headers 加在 Web Server 中比較合理</strong>。</p><h3 id="範例："><a href="#範例：" class="headerlink" title="範例："></a><font color=#d2691e>範例：</font></h3><p>其實要在 Web Server 中添加 Response Headers 很簡單。如在 Nginx 中，只須在我們 <code>*.conf</code> 文件中的 <code>server</code> 區塊中使用 <code>add_header</code> 關鍵字添加響應頭即可。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs conf">upstream uwsgi-webapi &#123;<br>    server nginx_webapi_web:8003;<br>&#125;<br><br>server &#123;<br>    listen 80;  # ipv4<br>    listen [::]:80;  # ipv6<br><br>    server_name django-sample-in-nginx;<br>    charset utf-8;<br><br>    location /static/ &#123;<br>        autoindex on;<br>        alias /usr/share/nginx/html/static/;<br>    &#125;<br><br>    location / &#123;<br>        uwsgi_pass uwsgi-webapi;<br>        include uwsgi_params;  <br>    &#125;<br>    <br>    # 在這邊添加即可<br>    add_header Content-Security-Policy &quot;default-src &#x27;self&#x27;;&quot;;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（四）- XSS</title>
    <link href="/2023/07/04/XSS/"/>
    <url>/2023/07/04/XSS/</url>
    
    <content type="html"><![CDATA[<p>之前在求學階段就有聽過 XSS 攻擊，但一直沒去深入了解它是什麼，今天趁這個機會來學習學習。</p><span id="more"></span><h2 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h2><p>在開始看文章以前，先定義等會在文章中看到的代名詞：</p><ul><li>Attacker：駭客</li><li>Website：被駭客發現有 XSS 漏洞的網站</li><li>Website Server：有 XSS 漏洞網站的後臺</li><li>Victim：受害的使用者</li></ul><h2 id="先來講講什麼是-XSS-攻擊？"><a href="#先來講講什麼是-XSS-攻擊？" class="headerlink" title="先來講講什麼是 XSS 攻擊？"></a>先來講講什麼是 XSS 攻擊？</h2><h3 id="XSS-簡介："><a href="#XSS-簡介：" class="headerlink" title="XSS 簡介："></a><font color=#d2691e>XSS 簡介：</font></h3><blockquote><p>全名為 Cross-Site Scripting，跨站腳本攻擊。</p></blockquote><p>XSS 多年來一直都是位列 OWASP 網頁安全漏洞的前十名。因此了解它對我們網頁開發者來說是非常重要的，且這不僅僅是前端的問題，後端也要做好相對應的防護才行。</p><p>通常 Attacker 是對<font color=#FF0000><strong>網站的輸入點</strong></font>（例如表單、留言板、URL 等）進行攻擊。<br>簡單的說，XSS 就是透過將<strong>惡意腳本</strong>埋進 Website 中，之後再誘使 Victim 去瀏覽頁面，當 Website 在加載的同時，惡意腳本也會跟著自動執行，導致 Victim 的機密資料洩漏（例如竊取 Cookie、劫持 Session 等）。</p><h2 id="XSS-三大種類："><a href="#XSS-三大種類：" class="headerlink" title="XSS 三大種類："></a>XSS 三大種類：</h2><h3 id="反射型-XSS（Reflected-XSS）："><a href="#反射型-XSS（Reflected-XSS）：" class="headerlink" title="反射型 XSS（Reflected XSS）："></a><font color=#d2691e>反射型 XSS（Reflected XSS）：</font></h3><p>反射型 XSS 是發生在<font color=#FF0000><strong>前後端未分離</strong></font>的情況下。因為<strong>後端沒有驗證前端傳來的輸入</strong>，所以後端在渲染 HTML 時，可能就會將夾帶惡意代碼的輸入一併渲染進去，此時只要回傳給前端並加載頁面後，就會遭受攻擊。</p><h4 id="攻擊手法："><a href="#攻擊手法：" class="headerlink" title="攻擊手法："></a><font color=#6495ed>攻擊手法：</font></h4><p>通常是將惡意腳本藏在網址列的 <strong>GET 參數</strong>中，然後透過社交工程信件讓 Victim 誤點網址，這樣就有可能被盜取機密資訊。</p><h4 id="一個簡單的範例："><a href="#一個簡單的範例：" class="headerlink" title="一個簡單的範例："></a><font color=#6495ed>一個簡單的範例：</font></h4><blockquote><p>假設 Website Server 返回的 HTML 會包括「欲搜尋的關鍵字（有可能帶有惡意腳本）」與「匹配的結果」。</p></blockquote><p>假設 Website 有個搜索頁面，會將搜尋的關鍵字<strong>丟向後端</strong>進行查詢，然後後端會渲染出一個 HTML 返回給前端。此時只要 Website 沒有驗證後端傳來的訊息，並直接加載頁面，惡意腳本就會被觸發了。</p><p>所以 Attacker 只要將惡意腳本帶在 query 參數之後，然後想辦法讓 Victim 點擊到即可，如下所示：</p><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">https://example.com/search?query=&lt;script&gt;alert(&#x27;XSS&#x27;)&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="簡易流程如下："><a href="#簡易流程如下：" class="headerlink" title="簡易流程如下："></a><font color=#6495ed>簡易流程如下：</font></h4><pre><code class=" mermaid">sequenceDiagramparticipant Attackerparticipant Victimparticipant Websiteparticipant Website ServerAttacker-&gt;&gt;Victim: 1.Victim-&gt;&gt;Website: 2.Website-&gt;&gt;Website Server: 3.Website Server-&gt;&gt;Website: 4.Website-&gt;&gt;Website: 5.Website-&gt;&gt;Attacker: 6.</code></pre><ol><li>Attacker 將<strong>帶有「惡意腳本」的網站連結</strong>傳給 Victim（例如透過 Email 等傳輸途徑）。</li><li><strong>Victim 點擊惡意連結</strong>，並將瀏覽器頁面導向 Website。</li><li>Website 向 Website Server 送出帶有惡意腳本參數的請求。</li><li>Website Server 將響應返回時，因沒做任何處理，也帶上了惡意腳本回來。</li><li>Website 渲染頁面時，惡意腳本也被偷偷運行。</li><li>腳本運行完後，將 Victim 的機密資訊回傳給 Attacker。</li></ol><h3 id="DOM-型-XSS-（DOM-based-XSS）："><a href="#DOM-型-XSS-（DOM-based-XSS）：" class="headerlink" title="DOM 型 XSS （DOM-based XSS）："></a><font color=#d2691e>DOM 型 XSS （DOM-based XSS）：</font></h3><p>嚴格來說 DOM-based XSS 其實也算反射型 XSS，區別在於 DOM-based XSS 只是<font color=#FF0000><strong>前端渲染問題</strong></font>，<strong>不會和後端進行交互</strong>。</p><h4 id="攻擊手法：-1"><a href="#攻擊手法：-1" class="headerlink" title="攻擊手法："></a><font color=#6495ed>攻擊手法：</font></h4><blockquote><p>錨點(<code>#</code>)：用於快速定位到網頁中的某個標記位置。錨點後面的名稱對應著網頁某區塊的 id，使用錨點可以讓網頁快速移動到指定的區塊。</p></blockquote><p>通常是將惡意腳本藏在網址列的<strong>錨點</strong>或是 <strong>GET 參數</strong>中，然後透過社交工程信件讓 Victim 誤點網址，這樣就有可能被盜取機密資訊。</p><h4 id="一個簡單的範例：-1"><a href="#一個簡單的範例：-1" class="headerlink" title="一個簡單的範例："></a><font color=#6495ed>一個簡單的範例：</font></h4><p>假設現在有個網頁（<code>http://example.com/home</code>）中包含以下程式碼：</p><blockquote><p><code>&lt;p&gt;</code> 標籤會根據 GET 參數的 name 字段改變內容。</p></blockquote><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span>Hi, xxx<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> quary_string = <span class="hljs-variable language_">document</span>.<span class="hljs-property">location</span>.<span class="hljs-property">search</span>;</span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> param_obj = <span class="hljs-keyword">new</span> <span class="hljs-title class_">URLSearchParams</span>(quary_string);</span><br><span class="language-javascript"></span><br><span class="language-javascript">            <span class="hljs-keyword">var</span> name = param_obj.<span class="hljs-title function_">get</span>(<span class="hljs-string">&quot;name&quot;</span>);</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span> (name !== <span class="hljs-string">&quot;null&quot;</span>) &#123;</span><br><span class="language-javascript">                <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;p1&quot;</span>).<span class="hljs-property">innerHTML</span> = <span class="hljs-string">&quot;Hi, &quot;</span> + name;</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure><p>這時駭客只要發送 <code>http://example.com/home?name=&lt;img+src+onerror=alert(&#39;XSS&#39;)&gt;</code> 的請求，則惡意腳本就會被執行並彈出一個帶有 “XSS” 的警告框。</p><h4 id="簡易流程如下：-1"><a href="#簡易流程如下：-1" class="headerlink" title="簡易流程如下："></a><font color=#6495ed>簡易流程如下：</font></h4><pre><code class=" mermaid">sequenceDiagramparticipant Attackerparticipant Victimparticipant WebsiteAttacker-&gt;&gt;Victim: 1.Victim-&gt;&gt;Website: 2.Website-&gt;&gt;Website: 3.Website-&gt;&gt;Attacker: 4.</code></pre><ol><li>Attacker 將<strong>帶有「惡意腳本」的網站連結</strong>傳給 Victim（例如透過 Email 等傳輸途徑）。</li><li><strong>Victim 點擊惡意連結</strong>，並將瀏覽器頁面導向 Website。</li><li>Website 加載頁面時，惡意腳本也被偷偷運行。</li><li>腳本運行完後，將 Victim 的機密資訊回傳給 Attacker。</li></ol><h3 id="儲存型-XSS-（Stored-XSS）："><a href="#儲存型-XSS-（Stored-XSS）：" class="headerlink" title="儲存型 XSS （Stored XSS）："></a><font color=#d2691e>儲存型 XSS （Stored XSS）：</font></h3><p>與前兩種手法不同，此種攻擊手法<strong>不需要使用社交工程釣魚</strong>，也能使 Victim 受到攻擊。</p><h4 id="攻擊手法：-2"><a href="#攻擊手法：-2" class="headerlink" title="攻擊手法："></a><font color=#6495ed>攻擊手法：</font></h4><p>這是 Attacker 透過將惡意腳本<strong>存儲在 Website Server</strong> 上，例如透過「留言板」留言。當 Victim 之後訪問這些被攻擊過的 Website 時，留言會被加載，惡意腳本就會被自動執行。</p><h4 id="一個簡單的範例：-2"><a href="#一個簡單的範例：-2" class="headerlink" title="一個簡單的範例："></a><font color=#6495ed>一個簡單的範例：</font></h4><p>最常見的例子就是將惡意腳本寫入留言板（這時惡意腳本就會被存到後端資料表中）。當下一位 Victim 瀏覽網頁時，網頁會載入留言板（就會順便把惡意腳本渲染出來），導致被攻擊。</p><p>範例如下：</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs javascript">&lt;script&gt;<span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;XSS&#x27;</span>)&lt;/script&gt;<br></code></pre></td></tr></table></figure><h4 id="簡易流程如下：-2"><a href="#簡易流程如下：-2" class="headerlink" title="簡易流程如下："></a><font color=#6495ed>簡易流程如下：</font></h4><pre><code class=" mermaid">sequenceDiagramparticipant Attackerparticipant Victimparticipant Websiteparticipant Website ServerAttacker-&gt;&gt;Website: 1.Website-&gt;&gt;Website Server: 2.Victim-&gt;&gt;Website: 3.Website-&gt;&gt;Website Server: 4.Website Server-&gt;&gt;Website: 5.Website-&gt;&gt;Website: 6.Website-&gt;&gt;Attacker: 7.</code></pre><ol><li>Attacker 在 Website 的留言板中輸入惡意腳本。</li><li>Website 向 Website Server 發請求，將留言存進資料庫（這時惡意腳本就會被存到後端了）。</li><li>Victim <strong>正常瀏覽</strong> Website。</li><li>Website 向 Website Server 發請求，要求讀取所有留言。</li><li>Website Server 返回留言（其中包含惡意腳本）。</li><li>Website 在渲染留言板的同時，也在偷偷運行惡意腳本。</li><li>腳本運行完後，將 Victim 的機密資訊回傳給 Attacker。</li></ol><h2 id="如何防範-XSS-攻擊？"><a href="#如何防範-XSS-攻擊？" class="headerlink" title="如何防範 XSS 攻擊？"></a>如何防範 XSS 攻擊？</h2><ol><li><p><font color=#6495ed><strong>輸入驗證與過濾：</strong></font><br>不管是前後端，對於所有輸入數據都要<strong>先假設為不可信的</strong>，包括表單提交、請求參數、留言板等，都應該進行驗證和過濾。確保<strong>只接受預期格式</strong>的數據，並過濾掉包含腳本標記的輸入。</p></li><li><p><font color=#6495ed><strong>設定 CSP 安全 HTTP Header：</strong></font><br>CSP（Content Security Policy）是瀏覽器提供<strong>設定白名單的機制</strong>，告訴瀏覽器哪些網頁的哪些位置可以連，限制允許載入的資源，如 JavaScript、CSS、字體和圖片等。</p><blockquote><p><code>Content-Security-Policy: script-src &#39;self&#39;</code>：表示只允許載入同源的 JavaScript 腳本。</p></blockquote></li><li><p><font color=#6495ed><strong>Cookie 設定 HTTP Only：</strong></font><br>讓 Cookie 無法被 JavaScript 所讀取，減少對於 Session 等機密被竊取的風險。</p></li><li><p><font color=#6495ed><strong>避免動態生成程式碼：</strong></font><br>前端避免使用 <code>document.write</code>、<code>innerHTML</code> 等函數來<strong>動態生成 DOM 元素</strong>，因為欲被轉換的字串中可能包含惡意腳本。</p></li><li><p><font color=#6495ed><strong>HTML Escaping：</strong></font><br>HTML Escaping 會對特殊字符（如 <code>&lt;</code>、<code>&gt;</code>、<code>&amp;</code>等）進行轉換。這樣同樣可以在 HTML 中正確顯示這些字符，且同時能<strong>防止腳本在瀏覽器中執行</strong>。</p><blockquote><p>如果未對 <code>&lt;script&gt;alert(&quot;XSS&quot;)&lt;/script&gt;</code> 進行轉義，將會被解釋為 JavaScript 腳本，並會在瀏覽器中執行。<br>但如果轉義成 <code>&amp;lt;script&amp;gt;alert(&amp;quot;XSS&amp;quot;)&amp;lt;/script&amp;gt;</code>，它同樣能正確顯示且不會被執行。</p></blockquote></li></ol>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（三）- CSRF</title>
    <link href="/2023/07/03/CSRF/"/>
    <url>/2023/07/03/CSRF/</url>
    
    <content type="html"><![CDATA[<p>在新手時期常常會看到有人將 CORS 與 CSRF 搞混，而我不意外也是其中一員。所以想藉此機會在這跟大家分享 CSRF 是什麼，大家有興趣也能去看看我本系列的另一篇文章 <a href="https://duke851230.github.io/2023/07/02/CORS/">Web 資安系列（二）- CORS</a>。</p><span id="more"></span><h2 id="那先來說說什麼是-CSRF-攻擊？"><a href="#那先來說說什麼是-CSRF-攻擊？" class="headerlink" title="那先來說說什麼是 CSRF 攻擊？"></a>那先來說說什麼是 CSRF 攻擊？</h2><h3 id="CSRF-簡介："><a href="#CSRF-簡介：" class="headerlink" title="CSRF 簡介："></a><font color=#d2691e>CSRF 簡介：</font></h3><blockquote><p>CSRF 全名為 Cross Site Request Forgery（跨站請求偽造）。</p></blockquote><p>從字面解釋上可以看出兩個重點「跨站」與「偽造請求」。<br>CSRF 攻擊簡單的說，就是指駭客在我們<strong>不知情的情況下</strong>，以<font color=#FF0000><strong>我們的名義</strong></font>對別的網站（例如：銀行）發送惡意請求（例如：刪除資料、轉帳等）。</p><h3 id="駭客如何做到偽造名義？"><a href="#駭客如何做到偽造名義？" class="headerlink" title="駭客如何做到偽造名義？"></a><font color=#d2691e>駭客如何做到偽造名義？</font></h3><blockquote><p>Cookie 是為了讓我們可以在 HTTP 請求中帶上狀態（例如：是否已登入），讓伺服器可以根據狀態做出不同的行為。</p></blockquote><p>駭客是利用 Web 的 <font color=#FF0000><strong>Cookie 機制</strong></font>來發起 CSRF 攻擊的。<br>因為瀏覽器會根據發起的請求自動帶上與之對應的 Cookie，駭客正是利用這點來攻擊的。例如只要在釣魚網站中埋下惡意轉帳的 API，當你用完網路銀行沒登出，然後又去到釣魚網站時，就可能會導致自己的錢默默被轉走，因為銀行網站看 Cookie 裡的登入資訊是你本人，它就會認為有權執行這個轉帳請求。</p><h2 id="如何防範-CSRF-攻擊？"><a href="#如何防範-CSRF-攻擊？" class="headerlink" title="如何防範 CSRF 攻擊？"></a>如何防範 CSRF 攻擊？</h2><p>防範措施分為「能有效防範」與「無效防範」兩種，不是說無效防範就沒有任何用處，它還是能提高一定的安全性。</p><h3 id="無效防範措施："><a href="#無效防範措施：" class="headerlink" title="無效防範措施："></a><font color=#d2691e>無效防範措施：</font></h3><ol><li><p><font color=#6495ed><strong>改用 POST 請求：</strong></font></p><p>雖然說 POST 的確比 GET 來得更安全，駭客在埋惡意請求時，不能直接簡單的埋在 <code>&lt;img&gt;</code> 標籤中，如下所示：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;https://xxx.blog.com/delete?id=3&#x27;</span> <span class="hljs-attr">width</span>=<span class="hljs-string">&#x27;0&#x27;</span> <span class="hljs-attr">height</span>=<span class="hljs-string">&#x27;0&#x27;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>但還是可以利用一個隱藏的 <code>&lt;iframe&gt;</code> 加上發惡意 POST 請求的 <code>&lt;form&gt;</code> 表單來攻擊。<br>只要先將表單中其他要傳的輸入框隱藏起來，只露出一個提交鍵來偽裝成一般按鈕，然後再將請求的結果導向隱藏的 <code>&lt;iframe&gt;</code> 即可。這樣點擊按鈕就不會跳出任何訊息，然後惡意請求就發出去了，非常可怕。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csrf-frame&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&#x27;POST&#x27;</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&#x27;https://xxx.blog.com/delete&#x27;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;csrf-frame&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;csrf-form&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;hidden&#x27;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&#x27;id&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;3&#x27;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&#x27;submit&#x27;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&#x27;點我你就會倒大楣&#x27;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&quot;csrf-form&quot;</span>).<span class="hljs-title function_">submit</span>()</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p><font color=#6495ed><strong>後端檢查請求頭中的 Referer 欄位：</strong></font></p><blockquote><p>Referer 是一個請求頭欄位，用來代表此請求是從哪裡來的。</p></blockquote><p>但因為 Referer 可以被使用者端自行關閉，這樣就會導致正常請求也會被阻擋。</p></li><li><p><font color=#6495ed><strong>後端在 API 上加入圖形驗證碼或簡訊驗證碼：</strong></font></p><p>雖然這的確能有效阻擋惡意請求，但如果你是使用者，會想每按一個按鍵就要輸入驗證碼嗎XD</p></li></ol><h3 id="有效防範措施："><a href="#有效防範措施：" class="headerlink" title="有效防範措施："></a><font color=#d2691e>有效防範措施：</font></h3><ol><li><p><font color=#6495ed><strong>添加同源政策：</strong></font></p><p>只要後端在 API 響應頭中的 <strong>Access-Control-Allow-Origin</strong> 限定可訪問的網域，這樣惡意網站就無法訪問了（因為在預檢請求時，瀏覽器就會將不合法的請求擋下）</p></li><li><p><font color=#6495ed><strong>Set-cookie 中使用 SameSite&#x3D;Strict：</strong></font></p><blockquote><p>SameSite 是 Cookie 本身的機制，瀏覽器會根據此欄位判斷要不要帶 Cookie。</p></blockquote><p>在 Cookie 中有一個 SameSite 欄位。只要將它設為 Strict，瀏覽器就會限制此 Cookie 只會在發出此請求網站的 Domain 與 Cookie Domain 欄位相同時帶上，所以在跨域的惡意網站中是無法使用的。</p><p>缺點：因為現在很多網站的後端和前端是部署在不同網域的，這樣就不能使用此方法</p><details> <summary>SameSite 選項：</summary> <pre>   Strict：限制此 Cookie 只允許與 Cookie Domain 相同的網域的請求送出（也稱為 First Party 請求）   Lax：除了 First Party 請求外，也允許某些特定的 GET 跨域請求（例如：a 標籤）帶上   None：允許所有請求帶上</pre></li></ol>  </details><ol start="3"><li><p><font color=#6495ed><strong>CSRF Token：</strong></font></p><blockquote><p>這裡的 Token 皆是由<font color=#FF0000><strong>後端</strong></font>產出，並要想辦法將其傳給前端。</p></blockquote><p>CSRF Token 的原理是只要確保某些資訊（Token）<strong>只有自己知道</strong>，就可用來判斷是不是惡意請求。</p><ul><li><p>在<strong>前後端未分離</strong>且使用 <strong>Form 表單</strong>的情況下：</p><p>因為 Html 是由後端生成的，所以能在渲染頁面時直接將 Token 寫進 Form 表單中的某個<strong>隱藏欄位</strong>，這樣之後就會隨著表單提交傳遞給後端了。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">form</span> <span class="hljs-attr">action</span>=<span class="hljs-string">&quot;/submit&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;POST&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;hidden&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;csrf_token&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;your_csrf_token_here&quot;</span>&gt;</span><br>  <span class="hljs-comment">&lt;!-- other form fields --&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;Submit&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在<strong>前後端分離</strong>且<strong>前後端同源</strong>的情況下：</p><p>因為前後端是同源的，所以在進行以下操作時，可<font color=#FF0000><strong>將 Cookie 的 SameSite 設為 Strict</strong></font>，增加網站安全性。  </p><ol><li><p>Server Side:</p><blockquote><p>因 Token 要能先被 js 讀取後，才能放到請求頭裡，故 <font color=#FF0000><strong>Cookie 的 Http Only 須設為 False</strong></font>。但這就有被 XSS 盜取 Cookie 的風險，所以前端須在其他方面做好對 XSS 攻擊的防護。<br>可以參考本系列的另一篇文章 <a href="https://duke851230.github.io/2023/07/04/XSS/">Web 資安系列（四）- XSS</a>。</p></blockquote><p>後端透過 Cookie 向前端傳遞 Token，而前端需要在之後的請求頭（X-CSRF-Token 欄位）中帶上此 Token。這樣後端只要驗證 Cookie 和 X-CSRF-Token 中的值是否一樣即可。</p></li><li><p>Client Side:</p><blockquote><p>這裡的 Token 是由<font color=#FF0000><strong>前端</strong></font>自行產出，適用於 SPA 網站。</p></blockquote><p>在這是<strong>由前端自行產生 Token</strong>，並分別放在 Cookie 與請求頭中，這樣後端只要驗證兩者是不是相同，就知道是不是惡意請求了。<br>而駭客網站因為<font color=#FF0000><strong>不同源</strong></font><strong>，沒辦法讀寫目標網站的 Cookie</strong>，所以請求頭的 Token 會跟 Cookie 內的會不一樣，這樣就能防止駭客攻擊。</p></li></ol></li><li><p>在<strong>前後端分離</strong>且<strong>前後端不同源</strong>的情況下：</p><blockquote><p>CSRF Token 就像是一次性使用的驗證碼，來讓 API 多一層保護。須注意 get_csrf_token API 要做好 <strong>CORS</strong> 的設定，不然駭客就也能取得 Token。</p></blockquote><p>因 Cookie 無法被不同源的地方獲取，故前後端只能透過 API 來傳遞 Token。前端在發送請求前，都須先呼叫另一支 API 取得 Token 並將其加入請求頭中。</p></li></ul></li></ol><h2 id="不要再將-CSRF、CORS-與-SOP-搞混了！"><a href="#不要再將-CSRF、CORS-與-SOP-搞混了！" class="headerlink" title="不要再將 CSRF、CORS 與 SOP 搞混了！"></a>不要再將 CSRF、CORS 與 SOP 搞混了！</h2><p>接下來跟大家科普一下 <code>CSRF</code>、<code>CORS</code>、<code>SOP</code>，雖然這三者之間有一定的關聯，但他們本質上是完全不同的東西。</p><h3 id="SOP："><a href="#SOP：" class="headerlink" title="SOP："></a><font color=#d2691e>SOP：</font></h3><blockquote><p>詳細可參考另一篇文章 <a href="https://duke851230.github.io/2023/07/01/SOP/">Web 資安系列（一）- SOP</a>。</p></blockquote><p>Same-origin policy（同源策略）是一種<strong>安全機制</strong>，主要是瀏覽器為了安全，限制跨來源資源的訪問與存取。</p><h3 id="CORS："><a href="#CORS：" class="headerlink" title="CORS："></a><font color=#d2691e>CORS：</font></h3><blockquote><p>詳細可參考另一篇文章 <a href="https://duke851230.github.io/2023/07/02/CORS/">Web 資安系列（二）- CORS</a>。</p></blockquote><p>Cross-Origin Resource Sharing（跨來源資源共用）可以理解為 SOP 的擴展機制，用於<strong>控制跨來源之間的資源共享</strong>。<br>CORS 通過在後端設定 HTTP 標頭，限制伺服器可以接受哪些請求，並只允許被授權的請求訪問資源。</p><h3 id="CSRF："><a href="#CSRF：" class="headerlink" title="CSRF："></a><font color=#d2691e>CSRF：</font></h3><p>CSRF 則是一種<strong>資安攻擊</strong>。指攻擊者透過網站中的安全漏洞，讓用戶在<strong>不知情</strong>的情況下，發送<strong>非預期的跨域請求</strong>。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（二）- CORS</title>
    <link href="/2023/07/02/CORS/"/>
    <url>/2023/07/02/CORS/</url>
    
    <content type="html"><![CDATA[<p>在介紹完 SOP 之後，不免俗的也要來講講 CORS（跨來源資源共用）是什麼，因為兩者間的關係密切，所以時常會一起被提出來講。<br>關於 SOP 能參考我的另一篇文章：<a href="https://duke851230.github.io/2023/07/01/SOP/">Web 資安系列（一）- SOP</a>。</p><span id="more"></span><h2 id="先來說說什麼是-CORS？"><a href="#先來說說什麼是-CORS？" class="headerlink" title="先來說說什麼是 CORS？"></a>先來說說什麼是 CORS？</h2><h3 id="CORS-簡介："><a href="#CORS-簡介：" class="headerlink" title="CORS 簡介："></a><font color=#d2691e>CORS 簡介：</font></h3><blockquote><p>全名為 Cross-Origin Resource Sharing，跨來源資源共用。</p></blockquote><p>這邊要先跟大家強調 CORS 是<strong>瀏覽器</strong>的一種機制，讓我們能對跨域訪問做更靈活的設置。</p><blockquote><p>須注意瀏覽器是<strong>阻擋 Server 的響應回傳給我們</strong>，而不是阻擋我們的請求到 Server！</p></blockquote><p>CORS 是用來針對<strong>某些時候需要使用不同源請求</strong>而誕生的。簡單的說，當我們想要透過瀏覽器對 Server 發出<strong>跨域請求</strong>時，瀏覽器會跟 Server 溝通哪些類型的請求是你能接受的，如果發現這是不被接受的請求時，瀏覽器就不會將 Server 的響應回傳給我們。</p><h3 id="什麼是跨源（Cross-Origin）？"><a href="#什麼是跨源（Cross-Origin）？" class="headerlink" title="什麼是跨源（Cross-Origin）？"></a><font color=#d2691e>什麼是跨源（Cross-Origin）？</font></h3><blockquote><p>詳細介紹能參考我的另一篇文章：<a href="https://duke851230.github.io/2023/07/01/SOP/">Web 資安系列（一）- SOP</a>。</p></blockquote><p>透過上述我們已經大約知道 CORS 的機制，我這邊再來跟大家講講要怎麼判斷請求是跨域的。主要是透過 Scheme（通訊協定）、Domain（網域）、Port（埠號）來判斷，只有三者完全一致才能算是同源的請求。  </p><h2 id="觀念釐清："><a href="#觀念釐清：" class="headerlink" title="觀念釐清："></a>觀念釐清：</h2><h3 id="跨域請求是被誰給擋下的？"><a href="#跨域請求是被誰給擋下的？" class="headerlink" title="跨域請求是被誰給擋下的？"></a><font color=#d2691e>跨域請求是被誰給擋下的？</font></h3><p>跨源請求是被<font color=#FF0000><strong>瀏覽器</strong></font>限制的。當發出跨域請求後，<strong>請求照樣會被送到 Server 端</strong>，只是回傳的 Response 被瀏覽器給擋下，所以我們才拿不到值。</p><blockquote><p><strong>下面的範例指的是簡單請求。</strong>若是使用非簡單請求的話，會先送出一個<strong>預檢請求</strong>，所以只要預檢請求沒過，就不會發送真正的 Request，也就不會刪到資料。</p></blockquote><p>所以才會說 GET 請求是最不安全的，因為如果用一個 GET API 來執行刪除操作，刪除動作一樣會被傳給 Server 上，只是刪除成功的回傳值被瀏覽器擋下而已（所以<strong>資料還是被成功刪除</strong>了）。</p><h3 id="為什麼不透過瀏覽器以外的方式攻擊？"><a href="#為什麼不透過瀏覽器以外的方式攻擊？" class="headerlink" title="為什麼不透過瀏覽器以外的方式攻擊？"></a><font color=#d2691e>為什麼不透過瀏覽器以外的方式攻擊？</font></h3><p>既然 CORS 是瀏覽器的機制，那我們使用 curl、postman 等來直接攻擊不就好了嗎？<br>因為通常機密資料都是藏在公司內網，我們無法從外網直接攻擊。</p><h3 id="開發時發現-CORS-阻擋，由誰解決？"><a href="#開發時發現-CORS-阻擋，由誰解決？" class="headerlink" title="開發時發現 CORS 阻擋，由誰解決？"></a><font color=#d2691e>開發時發現 CORS 阻擋，由誰解決？</font></h3><p>跨域請求是否能過主要是看 Server 端認不認識這個來源，所以要解決跨域問題一定得找<strong>後端</strong>配合解決。</p><h2 id="那前後端要如何設定-CORS-呢？"><a href="#那前後端要如何設定-CORS-呢？" class="headerlink" title="那前後端要如何設定 CORS 呢？"></a>那前後端要如何設定 CORS 呢？</h2><p>雖然目前大部分主流的 Web Framework（如 Django）都幫我們做好 CORS 大部分的實現細節，我們只須簡單配置即可。但還是在這邊紀錄一下對不同請求情況的 CORS 配置筆記。</p><h3 id="簡單請求："><a href="#簡單請求：" class="headerlink" title="簡單請求："></a><font color=#d2691e>簡單請求：</font></h3><blockquote><p>簡單請求的檢查最為寬鬆，也就表示最容易被攻擊，API 設計時須慎重考慮。</p></blockquote><p><strong>只會檢查請求是不是同源</strong>而已，故只須在後端回傳的 Response Header 中加入 <code>Access-Control-Allow-Origin</code> 欄位即可。瀏覽器會根據此欄位判斷是否要回傳響應。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br><br>app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h4 id="簡單請求的定義如下："><a href="#簡單請求的定義如下：" class="headerlink" title="簡單請求的定義如下："></a>簡單請求的定義如下：</h4><blockquote><p>Content-Type 為 application&#x2F;json 也是非簡單請求。</p></blockquote><ol><li>HTTP Method 只能為 GET、POST、HEAD。</li><li>Request Header 欄位只能有 Accept、Accept-Language、Content-Language、DPR、Downlink、Save-Data、Width、Last-Event-ID、Content-Type。</li><li>Content-Type 只能為 text&#x2F;plain、application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data 三種。</li></ol><h3 id="非簡單請求："><a href="#非簡單請求：" class="headerlink" title="非簡單請求："></a><font color=#d2691e>非簡單請求：</font></h3><p>當瀏覽器發現請求為不簡單請求時，瀏覽器會先發出<strong>預檢請求（Options）</strong>，先去 Server 驗證是否合法。</p><h4 id="非簡單請求的請求流程："><a href="#非簡單請求的請求流程：" class="headerlink" title="非簡單請求的請求流程："></a>非簡單請求的請求流程：</h4><ol><li>送出一個非簡單 Post 請求。</li><li>瀏覽器發現是非簡單請求，因此先發出一個 Preflight Request（預檢請求）給 Server，請求頭須帶上兩個額外欄位。<br><code>Access-Control-Request-Headers</code>：不符合簡單請求的 Header 欄位<br><code>Access-Control-Request-Methods</code>：實際請求的 Method</li><li>Server 預檢請求的響應頭中，通常會帶上幾個欄位。<br><code>Access-Control-Allow-Origin</code>：告訴瀏覽器可以存取此資源的 Origin<br><code>Access-Control-Allow-Methods</code>：告訴瀏覽器允許使用的 HTTP 方法<br><code>Access-Control-Allow-Headers</code>：告訴瀏覽器允許使用的自訂 HTTP Header</li><li>瀏覽器檢查 Preflight Response，發現預檢請求通過。</li><li>瀏覽器送出真正的 Post 請求到 Server</li></ol><blockquote><p>Option 和 Post 都須設置相對應的響應頭。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">options</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="hljs-string">&#x27;Content-Type, Authorization&#x27;</span><br>  &#125;);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>&#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="非-POST-的非簡單請求："><a href="#非-POST-的非簡單請求：" class="headerlink" title="非 POST 的非簡單請求："></a><font color=#d2691e>非 POST 的非簡單請求：</font></h3><p>跨來源請求<strong>預設只接受 GET、HEAD以 及 POST 類型</strong>。其他請求類型都須由後端回傳的 <code>Access-Control-Allow-Methods</code> 來判斷。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">options</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Methods&#x27;</span>: <span class="hljs-string">&#x27;PATCH&#x27;</span><br>  &#125;);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br><br>app.<span class="hljs-title function_">patch</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>&#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="帶-Cookie-的非簡單請求："><a href="#帶-Cookie-的非簡單請求：" class="headerlink" title="帶 Cookie 的非簡單請求："></a><font color=#d2691e>帶 Cookie 的非簡單請求：</font></h3><p>若跨域請求有帶 Cookie 的話，<code>Access-Control-Allow-Origin</code> 就不能設為 <code>&#39;*&#39;</code>，<strong>必須指定特定網域</strong>。<br>因為如果沒有這個限制的話，所有跨域請求都能帶上 Cookie 來訪問。這樣會有安全性問題產生，跟 CSRF 攻擊類似。</p><blockquote><p>後端須設置 <code>Access-Control-Allow-Credentials: true</code> ，瀏覽器才會讓跨域請求帶上 Cookie。<br>預檢請求與真實請求的 API 都須加上此欄位。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">options</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;http://duke.tw&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Headers&#x27;</span>: <span class="hljs-string">&#x27;Content-Type, Authorization&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;http://duke.tw&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>: <span class="hljs-literal">true</span><br>  &#125;);<br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>&#125;);<br>&#125;)<br></code></pre></td></tr></table></figure><p>若後端響應頭中有要帶上 Set-Cookie 的話（就算前端請求沒帶 Cookie），也須跟上面一樣設置 <code>Access-Control-Allow-Credentials: true</code>，不然 Set-Cookie 等於無效。</p><blockquote><p>在處理跨域請求的 Cookie 時，<strong>前端的 Ajax 也要做額外設定（withCredentials）</strong>，來保證 Cookie 不被攔截。<br>雖然有的瀏覽器會默認將 withCredentials 設為 true，但為了保險還是手動設定比較好。</p></blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>xhr.<span class="hljs-property">withCredentials</span> = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure><h3 id="須讓前端可存取後端-Response-Headers："><a href="#須讓前端可存取後端-Response-Headers：" class="headerlink" title="須讓前端可存取後端 Response Headers："></a><font color=#d2691e>須讓前端可存取後端 Response Headers：</font></h3><p>有時候後端可能會在 Response Header 中加入資訊，但如果要讓前端 JavaScript 可以讀到的話，須讓瀏覽器知道。</p><p>如果你要存取跨域請求的 Response Header，後端要多帶一個 <code>Access-Control-Expose-Headers</code>，讓瀏覽器知道哪些可以被 JavaScript 讀取。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;/hello&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;http://duke.tw&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Expose-Headers&#x27;</span>: <span class="hljs-string">&#x27;XXX-Version&#x27;</span>,<br>    <span class="hljs-string">&#x27;XXX-Version&#x27;</span>: <span class="hljs-string">&#x27;1.0.0&#x27;</span><br>  &#125;);<br>  res.<span class="hljs-title function_">send</span>(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure><h3 id="快取預檢請求："><a href="#快取預檢請求：" class="headerlink" title="快取預檢請求："></a><font color=#d2691e>快取預檢請求：</font></h3><p>如果同時收到大量同個非簡單的跨域請求的話，會導致很多重複的預檢請求。</p><p>為預檢請求 API 加上快取存活時間欄位（<code>Access-Control-Max-Age</code>，單位為秒），讓他多存活一段時間，之後對同一個資源都不會再打到後端去做預檢請求，而是會直接沿用快取的資料。</p><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript">app.<span class="hljs-title function_">options</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(&#123;<br>    <span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>: <span class="hljs-string">&#x27;*&#x27;</span>,<br>    <span class="hljs-string">&#x27;Access-Control-Max-Age&#x27;</span>: <span class="hljs-number">300</span><br>  &#125;);<br>  res.<span class="hljs-title function_">end</span>();<br>&#125;)<br><br>app.<span class="hljs-title function_">post</span>(<span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">req, res</span>) =&gt;</span> &#123;<br>  res.<span class="hljs-title function_">set</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;*&#x27;</span>);<br>  res.<span class="hljs-title function_">json</span>(&#123;<span class="hljs-string">&quot;success&quot;</span>: <span class="hljs-literal">true</span>&#125;);<br>&#125;)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Web 資安系列（一）- SOP</title>
    <link href="/2023/07/01/SOP/"/>
    <url>/2023/07/01/SOP/</url>
    
    <content type="html"><![CDATA[<p>做為 Web 資安系列的第一篇文章，我覺得應該先跟大家來聊聊瀏覽器的基礎安全機制——同源政策（SOP）。因為如果沒有了 SOP 的保障，駭客將可以輕易對我們的網站發起攻擊（例如：CSRF 攻擊），讓我們赤裸裸的暴露在危險之中。<br>關於 CSRF 攻擊也能參考我的另一篇文章：<a href="https://duke851230.github.io/2023/07/03/CSRF/">Web 資安系列（三）- CSRF</a>。</p><span id="more"></span><h2 id="先來說說什麼是-SOP？"><a href="#先來說說什麼是-SOP？" class="headerlink" title="先來說說什麼是 SOP？"></a>先來說說什麼是 SOP？</h2><h3 id="SOP-簡介："><a href="#SOP-簡介：" class="headerlink" title="SOP 簡介："></a><font color=#d2691e>SOP 簡介：</font></h3><blockquote><p>全稱為 Same Origin Policy，同源政策。</p></blockquote><p>SOP 是網站安全的基礎，是一種<strong>瀏覽器的安全機制</strong>，用於限制網頁應用在瀏覽器中訪問「跨來源資源」的能力。</p><blockquote><p>因為我們有些時候還是會想去使用外部的資源，所以 CORS 就誕生了，它可以讓我們<strong>更靈活的去設定跨域訪問權限</strong>。<br>詳細能參考我的另一篇文章：<a href="https://duke851230.github.io/2023/07/02/CORS/">Web 資安系列（二）- CORS</a>。</p></blockquote><p>而 SOP 跟我們不陌生的 CORS 息息相關。我們可以簡單理解 CORS 是<strong>基於 SOP 的擴展機制</strong>，允許伺服器可以授予特定來源對資源的訪問權限。</p><h3 id="可是為什麼要阻止跨來源訪問呢？"><a href="#可是為什麼要阻止跨來源訪問呢？" class="headerlink" title="可是為什麼要阻止跨來源訪問呢？"></a><font color=#d2691e>可是為什麼要阻止跨來源訪問呢？</font></h3><p>大家可以互拿資訊不是很好嗎，為什麼瀏覽器都要禁止跨來源訪問呢？ 因為安全性。</p><p>如果沒有了瀏覽器在外幫我們抵禦駭客，那公司內網就很容易受到攻擊。大家可以試想以下狀況，如果瀏覽器沒有了 SOP 機制會發生什麼事情？</p><h4 id="簡易的攻擊舉例："><a href="#簡易的攻擊舉例：" class="headerlink" title="簡易的攻擊舉例："></a><font color=#6495ed>簡易的攻擊舉例：</font></h4><p>如果沒有了 SOP 機制，駭客就能像這樣簡單的拿到我們主機 localhost 的服務資訊。</p><ol><li>駭客建立一個惡意網站</li><li>在裡面埋了獲取內網服務資訊的請求，如下所示：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">send_request</span>(<span class="hljs-params">url, callback</span>) &#123;<br>  <span class="hljs-keyword">const</span> req = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>  req.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>  req.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-title function_">callback</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>)<br>  &#125;;<br>  req.<span class="hljs-title function_">send</span>();<br>&#125;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> port = <span class="hljs-number">80</span>; port &lt; <span class="hljs-number">10000</span>; port++) &#123;<br>  <span class="hljs-title function_">send_request</span>(<br>    <span class="hljs-string">&quot;http://localhost:&quot;</span> + port,<br>    <span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;<br>      <span class="hljs-comment">// 將資料回傳給駭客</span><br>    &#125;<br>  )<br>&#125;<br></code></pre></td></tr></table></figure></li><li>有人在內網中點到了此惡意網站</li><li>駭客拿到機密資訊</li></ol><h2 id="同源政策類型："><a href="#同源政策類型：" class="headerlink" title="同源政策類型："></a>同源政策類型：</h2><p>同源政策是網站安全的基礎，在瀏覽器的實現中又分為兩種：</p><ul><li>DOM 的同源政策</li><li>Cookie 的同源政策</li></ul><h3 id="DOM-的同源政策："><a href="#DOM-的同源政策：" class="headerlink" title="DOM 的同源政策："></a><font color=#d2691e>DOM 的同源政策：</font></h3><p>無論是影片、圖片還是程式碼等資源，在被載入瀏覽器後就都是 DOM 元素。</p><h4 id="如何判斷這些資源是同源的呢？"><a href="#如何判斷這些資源是同源的呢？" class="headerlink" title="如何判斷這些資源是同源的呢？"></a><font color=#6495ed>如何判斷這些資源是同源的呢？</font></h4><blockquote><p>對 DOM 的同源政策來說，<strong>Scheme（通訊協定）</strong>、<strong>Domain（網域）</strong>跟 <strong>Port（埠號）</strong>一致的資源就會被視為同源。</p></blockquote><p>我們假設是在 <code>http://duke.tw</code> 網站中發送請求，所以我們請求的來源（Origin）就是 <code>http://duke.tw</code>。</p><table><thead><tr><th align="center">請求的 URL</th><th align="center">是否同源</th></tr></thead><tbody><tr><td align="center"><code>http://duke.tw/get_user</code></td><td align="center">是</td></tr><tr><td align="center"><code>http://test.duke.tw/get_user</code></td><td align="center">否，域名不同</td></tr><tr><td align="center"><code>http://duke.tw:81/get_user</code></td><td align="center">否，埠號不同</td></tr><tr><td align="center"><code>https://duke.tw/get_user</code></td><td align="center">否，協定不同</td></tr></tbody></table><h4 id="DOM-同源政策的例外行為："><a href="#DOM-同源政策的例外行為：" class="headerlink" title="DOM 同源政策的例外行為："></a><font color=#6495ed>DOM 同源政策的例外行為：</font></h4><p>你現在可能會有些疑惑，因為我的網站中明明會引入很多跨來源的資源（例如：圖片），那為什麼都是被允許的呢？<br>因為其實並不是所有的跨來源存取都是被禁止的，在某些特殊情況下是可被允許的。</p><ol><li><p>跨來源寫入通常被允許：</p><blockquote><p>但若是透過 JavaScript 程式碼，例如 XMLHttpRequest、Fetch API 是無法跨來源寫入的。</p></blockquote><p>例如：連結 (links) 、重新導向 (redirect) 、表單 (form) 是被允許的。</p></li><li><p>跨來源嵌入通常被允許：</p><blockquote><p>雖然跨來源嵌入的內容會直接顯示在瀏覽器中，但其內容是<strong>無法被 JavaScript 程式碼所讀取的</strong>。<br>例如：我們無法讀取 <code>&lt;iframe&gt;</code> 中的元素。</p></blockquote><p>例如：圖片（<code>&lt;img&gt;</code>）、影片（<code>&lt;video&gt;</code>）、CSS（<code>&lt;link rel=&quot;stylesheet&quot; href=&quot;...&quot;&gt;</code>）、內嵌框架（<code>&lt;iframe&gt;</code>）等通常是被允許的。</p></li><li><p>跨來源讀取通常不被允許：</p><p>例如：使用 XMLHttpRequest、Fetch API 去獲取外部資訊。</p></li></ol><p>由上述我們可以總結出「SOP 對於 HTML 標籤產生的跨來源操作較為寬容，而<strong>對於 JavaScript 產生的跨來源操作是有限制的</strong>」。</p><h4 id="潛在的安全問題："><a href="#潛在的安全問題：" class="headerlink" title="潛在的安全問題："></a><font color=#6495ed>潛在的安全問題：</font></h4><p>因為 SOP 對於連結 (links) 、重新導向 (redirect) 、表單 (form) 等的跨來源存取是寬鬆的，所以有可能會被駭客所利用。</p><h3 id="Cookie-的同源政策："><a href="#Cookie-的同源政策：" class="headerlink" title="Cookie 的同源政策："></a><font color=#d2691e>Cookie 的同源政策：</font></h3><h4 id="如何判斷-Cookie-是同源的呢？"><a href="#如何判斷-Cookie-是同源的呢？" class="headerlink" title="如何判斷 Cookie 是同源的呢？"></a><font color=#6495ed>如何判斷 Cookie 是同源的呢？</font></h4><blockquote><p>對 Cookie 的同源政策來說，只要 <strong>Domain（網域）</strong> 跟 <strong>Path（路徑）</strong>一致就會被視為同源，<font color=#FF0000><strong>跟 Port（埠號）無關</strong></font>。<br>而 <strong>Scheme（通訊協定）</strong>是根據此 Cookie 的 Secure 設定而定，用來判斷是否要 HTTPS 才能帶上 Cookie。</p></blockquote><p>在我們發出請求時，瀏覽器就會將與該請求同源的 Cookie 一起帶上。</p><h4 id="子母網域是能共用-Cookie-的："><a href="#子母網域是能共用-Cookie-的：" class="headerlink" title="子母網域是能共用 Cookie 的："></a><font color=#6495ed>子母網域是能共用 Cookie 的：</font></h4><p>與 DOM 的同源政策不同，在 Cookie 中是<strong>可以做到 Domain 與 SubDomain 共用 Cookie 的</strong>！</p><p>當 Cookie 的 Domain 被設定為：</p><blockquote><p>此時的 Cookie 不會與子網域（例如：api.duke.tw）共用。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Cookie: name=value; domain=duke.tw<br></code></pre></td></tr></table></figure><p>但若是設定為：</p><blockquote><p>該 Cookie 可以在瀏覽器連上子網域時，也會一並回傳到網站主機。</p></blockquote><figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs text">Cookie: name=value; domain=.duke.tw<br></code></pre></td></tr></table></figure><h4 id="潛在的安全問題：-1"><a href="#潛在的安全問題：-1" class="headerlink" title="潛在的安全問題："></a><font color=#6495ed>潛在的安全問題：</font></h4><p>若 Cookie 設定成子母網域共用的話，可能會被駭客所利用，例如透過子網域去修改母網域的 Cookie。</p>]]></content>
    
    
    <categories>
      
      <category>Web</category>
      
      <category>Security</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Security</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
